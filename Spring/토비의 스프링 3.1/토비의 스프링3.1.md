# 목차

- [1장 오브젝트와 의존관계](#1장)
- [3장 템플릿](#3장)
- [4장 예외](#4장)
- [5장 서비스추상화](#5장)
- [6장 AOP](#6장)
- [7장 스프링 핵심 기술 응용](#7장)

# 1장

---

## 관심사를 분리해야 하는 이유

요구사항은 끊임없이 변경되고 발전한다. 모든 관심사들이 한 곳에 응집되어 있다면 해당 오브젝트는 끊임없이 변화해야 한다. 추가로 해당 오브젝트를 의존하고 있는 다른 오브젝트에까지 영향이 갈 수 있다. 이 변화의 폭을 최소화하기 위해서 관심사를 최대한 분리해야 한다.

### 오브젝트끼리 의존을 제거하면 되지 않는가?

불필요한 코드의 중복이 많아질 수 있다. 예를 들어 UserDao, BoardDao, CommentDao에서 DB 연동과 관련된 설정이 필요하다고 가정해보자. 모든 Dao에서 DB 연동 코드를 작성할 것인가? DB 연동 방법이 바뀌기라도 하면 모든 Dao를 수정해야하는 일이 발생한다.

---

## 스프링이 관심사 분리를 돕는 방법

IoC와 DI를 활용할 수 있다.

---

## 인터페이스를 도입해야 하는 이유

한 기능에 대해 구현 방법이 여러가지 존재할 때 매번 오브젝트를 수정하는 것은 번거로운 일이다. 이런 기능에 대한 변경이나 확장을 유연하게 하기 위해서는 크게 상속과 인터페이스 두 가지 방법이 있다. Java에서 상속은 다중 상속이 불가능하다, 슈퍼 클래스의 변경이 서브 클래스에게까지 미칠 수 있다 등의 제약이 있어 인터페이스가 좀 더 유연하게 사용하기 쉽다.

---

## 관계 설정의 책임이 분리되면 무엇이 좋은가

오브젝트에서 어떤 오브젝트와 의존을 맺을지에 대한 것도 하나의 관심사다. 관심사를 분리해야 하는 이유를 생각해보자.

---

## 개방 폐쇄의 원칙이란

클래스나 모듈은 확장에 대해서는 열려 있고 변경에 대해서는 닫혀 있어야한다는 의미이다. 기능을 변경하거나 확장할 수 있으면서도 그 기능을 사용하는 코드에서는 수정되지 않는다. 예를 들면 UserDao에서는 ConnectMaker라는 인터페이스를 이용해 DB 연결과 관련된 로직을 수행하고 있다. ConnectMaker를 통해 DB 연결 방법은 언제든지 바뀔 수 있다. 하지만 ConnectMaker의 변경으로 인해 UserDao의 로직은 변경될 필요가 없다. 이 경우 개방 폐쇄의 원칙을 따른다고 표현할 수 있다.

---

## 전략 패턴이란

인터페이스를 통해 로직을 외부에 분리시키고 이를 구현한 클래스를 필요에 따라 바꿔 사용할 수 있게 하는 디자인 패턴. ConnectMaker라는 인터페이스를 DB 종류에 따라 MySqlConnectMaker, H2SConnectMaker, MongoDbConnectMaker 등으로 구현체를 생성하고 이를 사용하는 UserDao에서는 필요한 구현체를 사용하면 된다.

---

## IoC란 = Inversion of Control = 제어의 역전

자신이 사용할 오브젝트를 선택하는 책임을 다른 대상에게 위임하는 것이다.

ex) 프레임워크: 라이브러리는 애플리케이션 코드가 능동적으로 필요할 때에 라이브러리의 기능을 사용한다. 반면 프레임워크는 애플리케이션 코드가 프레임워크에 의해 사용된다. 프레임워크가 짜놓은 틀에서 수동적으로 동작하는 것이다.

---

## 스프링의 IoC 동작 방식

- bean: 스프링이 직접 생성 및 제어하는 오브젝트
- bean factory: bean 생성 및 제어를 담당하는 스프링 IoC 핵심 컨테이너
- pplication context: bean factory를 확장한 IoC 컨테이너. 스프링의 부가 서비스를 추가로 제공
- bean과 application context를 이용해 IoC를 관리한다.

---

## 싱글톤 패턴의 한계

싱글톤은 private 생성자를 가지기 때문에 상속이 불가능하고 테스트하기 힘들다. 클래스 로더를 어떻게 구성하느냐에 따라 하나 이상의 오브젝트가 만들어질 수 있어 싱글톤이 하나만 만들어진다 보장하기 힘들고, 전역 상태로 사용하기 위해 싱글톤을 적용하는 올바르지 못한 상황이 만들어질 수 있다.

---

## 싱글톤 레지스트리란

싱글톤을 저장하고 관리하는 스프링의 기능이다. public 생성자를 갖기 때문에 테스트를 유연하게 작성할 수 있다. 싱글톤 패턴의 일부 단점이 완화되었다.

### 싱글톤 레지스트리를 적용하면 싱글톤 패턴의 단점이 완화되는가?

적용하면서 일부 싱글톤 패턴의 단점이 완화되기는 했지만 싱글턴 패턴의 단점을 극복하기 위해 스프링이 등장한 것은 아니다. 빈을 직접 만들고 이를 싱글턴 레지스트리로 관리하기로 했을 뿐이다.

---

## 스프링 빈 스코프의 종류

- 싱글톤: default. 오브젝트 하나만 생성
  프로토타입: 빈 요청할 때마다 오브젝트 새로 생성
- 요청: HTTP 요청 생길때마다 생성
- 세션: 웹의 세션과 유사한 스코프

---

## DI란 = Dependency Injection = 의존관계 주입

A 오브젝트가 B 오브젝트에 의존한다. B 오브젝트가 변경되면 A 오브젝트에도 영향을 미친다는 의미이다. 의존관계는 코드 상에서 직접 드러날 수도 있지만 런타임 시에 생성되는 경우도 있다. 이런 런타임 시 의존관계를 맺는 대상(의존 오브젝트)와 이를 사용하는 주체(클라이언트)를 연결해주는 작업을 의존관계 주입이라고 한다.

# 3장

## 분리와 재사용을 위한 디자인 패턴

크게 2가지가 존재한다.

### 템플릿 메소드 패턴

변하지 않는 부분은 슈퍼 클래스에, 변하는 부분은 추상 메소드로 정의하는 방법이다. 변하는 부분은 서브 클래스에서 재정의하여 원하는 로직을 작성한다. 매번 상속이 이루어져야 한다는 단점이 있다.

### 전략 패턴

인터페이스를 활용한 방법으로 오브젝트를 아예 분리한다. 클래스 레벨에서는 인터페이스를 통해 의존하고 클래스의 외부에서 원하는 오브젝트를 주입시킨다.

---

## 템플릿/콜백이란?

전략 패턴과 익명 내부 클래스를 활용한 방식이다. 전략 패턴의 컨텍스트를 템플릿, 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 한다. 로직이 담긴 콜백 오브젝트를 템플릿에 전달하면 템플릿은 해당 콜백 오브젝트의 로직을 호출한다. 호출된 로직이 반환해준 값을 이용해 템플릿은 템플릿 내부의 나머지 로직을 수행하고 최종 결과를 클라이언트에게 전달한다. 대표적으로 Spring의 JdbcTemplate이 해당 패턴을 도입해 만들어졌다.

---

## 제네릭을 콜백에서 어떻게 활용하는가

반환 결과의 타입을 다양하게 받고 싶은 경우 사용한다.

```java
public interface TestCallback<T> {
    T execute(String value1, T value2);
}
```

# 4장

## 예외를 처리하는 방법 3가지

예외 회피 / 전환 / 복구

    회피: 메서드에 throws를 달아 예외 처리하는 역할을 메서드를 호출한 쪽에게 맡기는 것
    전환: 적절한 예외로 변경하여 던지는 것
    복구: 예외 상황을 해결해 정상 상태로 돌려놓는 것

---

## JdbcTemplate에서 SqlException이 사라진 이유

더 구체적이고 적절한 예외로 변경하여 던져주고 있기 때문

---

## DataAccessException의 계층 구조

RuntimeException을 상속하고 있으며 하위에 더 구체적이고 다양한 종류의 Exception들이 존재한다.

# 5장

## ENUM의 사용 목적

상수를 편리하고 의미 있는 형태로 관리할 수 있다. 잘못된 상수를 사용하는 경우 컴파일 에러를 띄울 수 있다.

---

## JDBC 트랜잭션

Connection 오브젝트를 이용해 트랜잭션의 시작과 종료를 지정할 수 있다. 자동 커밋 옵션을 false로 지정한 뒤 수동으로 커밋/롤백 시점을 정할수도 있다.

---

## 트랜잭션 경계를 설정하는 방법

트랜잭션을 적용할 시작 지점부터 끝 지점. 특정 범위 내의 로직을 하나의 작업으로 묶어 전부 commit 또는 rollback을 적용할지 지정할 수 있다. Connection 객체에서 setAutoCommit(false)를 통해 트랜잭션을 시작하고 commit() 또는 rollback()을 통해 트랜잭션을 종료할 수 있다.

---

## 트랜잭션 동기화란?

트랜잭션 시작을 위해 만든 Connection을 특별한 저장소에 보관해두었다 이후에 호출되는 로직에서 저장되었던 Connection을 사용하게 하는 것이다. 트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 관리하기 때문에 멀티 스레드 환경에서 충돌의 걱정을 하지 않아도 된다.

---

## JdbcTemplate의 트랜잭션 동기화

트랜잭션 동기화 저장소에 등록된 DB Connection 또는 트랜잭션이 없는 경우에는 JdbcTemplate이 직접 DB Connection을 생성하고 트랜잭션을 시작해 JDBC 작업을 진행한다. 트랜잭션 동기화를 시작해두었다면 그때부터 실행되는 JdbcTemplate의 메서드에서는 트랜잭션 동기화 저장소에 들어있는 DB Connection을 가져와 사용한다.

---

## 단일 책임 원칙이란

하나의 모듈은 하나의 책임만 가져야한다는 원칙이다. 하나의 모듈이 바뀌는 이유는 단 한가지 뿐이어야 하며 변경이 일어나는 경우 수정 대상이 명확해진다.

---

## 수직적인 계층 구조 vs 수평적인 계층 구조

두 계층 구조 둘 다 로직을 나누면서 만들어낼 수 있다. 수직적인 계층 구조는 다른 계층의 특성을 갖는 코드를 분리한 것이다. 수평적인 계층 구조는 같은 애플리케이션 로직을 가진 코드지만 내용에 따라 분리한 것이다. (=같은 계층에서의 수평적인 분리)

# 6장

## AOP란?

Aspect Oriented Programming의 약자로 핵심 기능과 부가 기능을 분리해 개발자들이 핵심 기능에 집중하여 개발할 수 있게 한다.

---

## AOP의 동작 방식

스프링의 AOP는 프록시를 이용해 동작하여 @EnableAspectJAutoProxy를 필수적으로 사용해야 한다. 이 때 만드는 프록시는 JDK에서 만드는 프록시와 CGLIB이 있는데 자세한 설명은 다음에 별도로 포스팅하겠다.

---

## 프록시란?

프록시란 자신이 클라이언트가 사용하려는 실제 대상인 것처럼 위장한다, 클라이언트의 요청을 받아주는 대리자 같은 역할을 한다하여 붙여진 이름이다.

---

## 프록시 패턴

타깃에 대한 접근 방법을 제어하기 위해 프록시를 사용하는 방법이다. 데코레이터 패턴과 다르게 타깃의 기능을 확장하려는 목적으로 사용하지 않는다. 타깃 오브젝트를 생성하기 복잡하거나 당장 필요가 없다면 필요한 시점까지 오브젝트를 생성하지 않는 것이 좋다. 이때 프록시 패턴이 유용하게 쓰이는데 생성이 복잡한 타깃 오브젝트에서 필요한 시점이 오기 전까지 레퍼런스를 가질 수 있게 해준다.

---

## 데코레이터 패턴

타깃에 부가적인 기능을 런타임 시 동적으로 부여해주기 위해 프록시를 사용하는 패턴이다. 코드 상에서는 어떤 방법으로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않고 런타임 시 결정된다. 사탕 껍질처럼 여러겹 쌓여있을 수 있다하여 데코레이터라는 이름이 붙었다.

---

## 팩토리 빈

스프링은 빈을 생성하는 여러 방법을 제공한다. 그 중 하나가 팩토리 빈이다. 팩토리 빈이란 스프링을 대신해 오브젝트의 생성 로직을 담당하도록 만들어진 특별한 빈이다.

---

## DefaultAdvisorAutoProxyCreator의 역할

자동 프록시 생성기. 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾고 Advisor의 Pointcut을 적용해보며 프록시 적용 대상을 선정한다. 프록시 선정 대상이라면 프록시를 만들어 원래 빈 오브젝트와 바꿔치기한다.

---

## 포인트컷이란

부가 기능을 적용할 위치.

---

## AOP로 트랜잭션 처리하기

Spring에서는 AOP 방식으로 트랜잭션을 처리할 수 있게 @Transactional이라는 어노테이션이 제공된다.

---

## 선언적 트랜잭션

AOP를 이용해 코드 외부에서 트랜잭션 기능이나 속성을 지정할 수 있게 하는 방법. 직접 코드를 작성하지 않고 핵심 비즈니스 로직과 분리시킨다.

---

# 7장

## SQL과 DAO를 분리하는 방법

DAO의 외부에서 SQL을 주입시키게 만들면 된다. @value 어노테이션을 이용할 수도 있고 SQL 목록을 저장하는 역할의 클래스를 따로 만들수도 있다.

---

## bean의 초기화 과정

@PostConstruct 어노테이션을 단 메서드를 이용해 초기화된다.
다만 현재 버전에서는 depreacated된 기능이고 이제는 InitializingBean 인터페이스를 이용한다.

---

## 자기참조 빈 설정 방법

xml을 이용하면 자기참조 빈을 설정할 수 있다.
