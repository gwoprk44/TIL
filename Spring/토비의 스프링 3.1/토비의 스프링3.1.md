# 목차

- [1장 오브젝트와 의존관계](#1장)
  - [관심사를 분리해야하는 이유](#관심사를-분리해야-하는-이유)
    - [오브젝트끼리 의존을 제거하면 되지 않는가?](#오브젝트끼리-의존을-제거하면-되지-않는가)
  - [스프링이 관심사 분리를 돕는 방법](#스프링이-관심사-분리를-돕는-방법)
  - [인터페이스를 도입해야 하는 이유](#인터페이스를-도입해야-하는-이유)
  - [관계 설정의 책임이 분리되면 무엇이 좋은가](#관계-설정의-책임이-분리되면-무엇이-좋은가)
  - [개방 폐쇄의 원칙이란](#개방-폐쇄의-원칙이란)
  - [전략 패턴이란](#전략-패턴이란)
  - [IoC란 = Inversion of Control = 제어의 역전](#ioc란--inversion-of-control--제어의-역전)
  - [스프링의 IoC 동작방식](#스프링의-ioc-동작-방식)
  - [싱글톤 패턴의 한계](#싱글톤-패턴의-한계)
  - [싱글톤 레지스트리란](#싱글톤-레지스트리란)
    - [싱글톤 레지스트리를 적용하면 싱글톤 패턴의 단점이 완화되는가?](#싱글톤-레지스트리를-적용하면-싱글톤-패턴의-단점이-완화되는가)
  - [DI란](#di란)
- [2장 테스트](#2장)
  - [웹을 이용한 테스트의 문제점](#웹을-이용한-테스트의-문제점)
  - [JUnit이란?](#junit이란)
  - [테스트를 해야하는 이유](#테스트를-해야하는-이유)
  - [테스트 코드 작성시 유의할 점](#테스트-코드-작성-시-유의할-점)
  - [DI를 통한 테스트 방법](#di를-통한-테스트-방법)
  - [테스트의 컨텍스트 공유](#테스트-컨텍스트의-공유)
- [3장 템플릿](#3장)
  - [JDBC란 무엇인가](#jdbc란-무엇인가)
  - [분리와 재사용을 위한 디자인 패턴](#분리와-재사용을-위한-디자인-패턴)
    - [전략패턴](#전략패턴)
  - [템플릿/콜백이란?](#템플릿콜백이란)
  - [제네릭을 콜백에서 활용하는법](#제네릭을-콜백에서-활용하는법)


# 1장

## 관심사를 분리해야 하는 이유

요구사항은 끊임없이 변경되고 발전한다. 모든 관심사들이 한 곳에 응집되어 있다면 해당 오브젝트는 끊임없이 변화해야 한다. 추가로 해당 오브젝트를 의존하고 있는 다른 오브젝트에까지 영향이 갈 수 있다. 이 변화의 폭을 최소화하기 위해서 관심사를 최대한 분리해야 한다.

### 오브젝트끼리 의존을 제거하면 되지 않는가?

불필요한 코드의 중복이 많아질 수 있다. 예를 들어 UserDao, BoardDao, CommentDao에서 DB 연동과 관련된 설정이 필요하다고 가정해보자. 모든 Dao에서 DB 연동 코드를 작성할 것인가? DB 연동 방법이 바뀌기라도 하면 모든 Dao를 수정해야하는 일이 발생한다.

## 스프링이 관심사 분리를 돕는 방법

IoC와 DI를 활용할 수 있다.

## 인터페이스를 도입해야 하는 이유

한 기능에 대해 구현 방법이 여러가지 존재할 때 매번 오브젝트를 수정하는 것은 번거로운 일이다. 이런 기능에 대한 변경이나 확장을 유연하게 하기 위해서는 크게 상속과 인터페이스 두 가지 방법이 있다. Java에서 상속은 다중 상속이 불가능하다, 슈퍼 클래스의 변경이 서브 클래스에게까지 미칠 수 있다 등의 제약이 있어 인터페이스가 좀 더 유연하게 사용하기 쉽다.

## 관계 설정의 책임이 분리되면 무엇이 좋은가

오브젝트에서 어떤 오브젝트와 의존을 맺을지에 대한 것도 하나의 관심사다. 관심사를 분리해야 하는 이유를 생각해보자.

## 개방 폐쇄의 원칙이란

클래스나 모듈은 확장에 대해서는 열려 있고 변경에 대해서는 닫혀 있어야한다는 의미이다. 기능을 변경하거나 확장할 수 있으면서도 그 기능을 사용하는 코드에서는 수정되지 않는다. 예를 들면 UserDao에서는 ConnectMaker라는 인터페이스를 이용해 DB 연결과 관련된 로직을 수행하고 있다. ConnectMaker를 통해 DB 연결 방법은 언제든지 바뀔 수 있다. 하지만 ConnectMaker의 변경으로 인해 UserDao의 로직은 변경될 필요가 없다. 이 경우 개방 폐쇄의 원칙을 따른다고 표현할 수 있다.

## 전략 패턴이란

인터페이스를 통해 로직을 외부에 분리시키고 이를 구현한 클래스를 필요에 따라 바꿔 사용할 수 있게 하는 디자인 패턴. ConnectMaker라는 인터페이스를 DB 종류에 따라 MySqlConnectMaker, H2SConnectMaker, MongoDbConnectMaker 등으로 구현체를 생성하고 이를 사용하는 UserDao에서는 필요한 구현체를 사용하면 된다.

## IoC란 = Inversion of Control = 제어의 역전

자신이 사용할 오브젝트를 선택하는 책임을 다른 대상에게 위임하는 것이다.

ex) 프레임워크: 라이브러리는 애플리케이션 코드가 능동적으로 필요할 때에 라이브러리의 기능을 사용한다. 반면 프레임워크는 애플리케이션 코드가 프레임워크에 의해 사용된다. 프레임워크가 짜놓은 틀에서 수동적으로 동작하는 것이다.

## 스프링의 IoC 동작 방식

bean: 스프링이 직접 생성 및 제어하는 오브젝트
bean factory: bean 생성 및 제어를 담당하는 스프링 IoC 핵심 컨테이너
application context: bean factory를 확장한 IoC 컨테이너. 스프링의 부가 서비스를 추가로 제공

bean과 application context를 이용해 IoC를 관리한다.

## 싱글톤 패턴의 한계

싱글톤은 private 생성자를 가지기 때문에 상속이 불가능하고 테스트하기 힘들다. 클래스 로더를 어떻게 구성하느냐에 따라 하나 이상의 오브젝트가 만들어질 수 있어 싱글톤이 하나만 만들어진다 보장하기 힘들고, 전역 상태로 사용하기 위해 싱글톤을 적용하는 올바르지 못한 상황이 만들어질 수 있다.

## 싱글톤 레지스트리란?
싱글톤을 저장하고 관리하는 스프링의 기능이다. public 생성자를 갖기 때문에 테스트를 유연하게 작성할 수 있다. 싱글톤 패턴의 일부 단점이 완화되었다.

### 싱글톤 레지스트리를 적용하면 싱글톤 패턴의 단점이 완화되는가?

적용하면서 일부 싱글톤 패턴의 단점이 완화되기는 했지만 싱글턴 패턴의 단점을 극복하기 위해 스프링이 등장한 것은 아니다. 빈을 직접 만들고 이를 싱글턴 레지스트리로 관리하기로 했을 뿐이다.

## 스프링 빈 스코프의 종류

싱글톤: default. 오브젝트 하나만 생성
프로토타입: 빈 요청할 때마다 오브젝트 새로 생성
요청: HTTP 요청 생길때마다 생성
세션: 웹의 세션과 유사한 스코프

## DI란

= Dependency Injection = 의존관계 주입
A 오브젝트가 B 오브젝트에 의존한다. B 오브젝트가 변경되면 A 오브젝트에도 영향을 미친다는 의미이다. 의존관계는 코드 상에서 직접 드러날 수도 있지만 런타임 시에 생성되는 경우도 있다. 이런 런타임 시 의존관계를 맺는 대상(의존 오브젝트)와 이를 사용하는 주체(클라이언트)를 연결해주는 작업을 의존관계 주입이라고 한다.

# 2장

## 웹을 이용한 테스트의 문제점

매번 실행 또는 배포를 시켜야해서 느림. 내 의도대로 코드가 동작하는지 빠른 시간내 확인이 불가능하고 테스트중 에러가 발생하면 어디서 문제가 발생했는지 찾는 과정이 필요.

## JUnit이란?

자바로 단위 테스트를 만들 때 사용하는 프레임워크.

## 테스트를 해야하는 이유

코드를 확신할 수 있게하고 변화에 유연하게 대처.
자주 반복 가능.

## 테스트 코드 작성 시 유의할 점

테스트는 항상 일관된 결과가 보장되어야 한다. 외부 환경이나 테스트 실행 순서에 영향을 받으면 안된다.

## DI를 통한 테스트 방법

JUnit4의 @Runwith(SpringJUnit4ClassRunner.class)는 JUnit5에서 @ExtendWith(SpringExtension.class)로 대체되었다.
해당 어노테이션을 통해 테스트 컨텍스트를 제공받고 @ContextConfiguration을 통해 어떤 애플리케이션 컨텍스트를 만들어줄지 선택할 수 있다.
테스트 코드에서는 @Autowired를 통해 bean으로 등록된 객체를 자동으로 주입받을 수 있다.

```JAVA
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = DaoConfig.class)
class UserDaoTest {
    @Autowired
    private UserDao userDao;
    @BeforeEach
    void delete() {
        userDao.deleteAll();
    }
    @DisplayName(value = "사용자 조회하기")
    @Test
    void findById() {
        // given
        User user = new User("id", "name", "1234");
        userDao.add(user);
        // when
        User actual = userDao.findById(user.getId());
        // then
        assertThat(actual).isEqualTo(user);
    }
}
```

## 테스트 컨텍스트의 공유

여러 개의 테스트 클래스가 같은 설정파일을 사용하는 경우 같은 애플리케이션 컨텍스트를 공유한다.

# 3장

## JDBC란 무엇인가

[링크](https://github.com/gwoprk98/TIL/blob/master/Spring/jdbc/JDBC%EA%B0%80%20%EB%93%B1%EC%9E%A5%ED%95%9C%20%EC%9D%B4%EC%9C%A0.md)로 설명 대체

## 분리와 재사용을 위한 디자인 패턴

이는 크게 두가지가 존재한다.

1. 템플릿 메소드 패턴
변하지 않는 부분은 슈퍼 클래스에, 변하는 부분은 추상 메소드로 정의하는 방법이다. 변하는 부분은 서브 클래스에서 재정의하여 원하는 로직을 작성한다. 매번 상속이 이루어져야 한다는 단점이 있다.
2. 전략 패턴
인터페이스를 활용한 방법으로 오브젝트를 아예 분리한다. 클래스 레벨에서는 인터페이스를 통해 의존하고 클래스의 외부에서 원하는 오브젝트를 주입시킨다.

### 전략패턴

객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고 유사한 행위들을 캡슐화 하는 인터페이스로 정의. 
객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법

예를 들어 move()에 대한 로직을 캡슐화하고 싶다라고 한다면

1. move() 메소드를 포함한 MoveStrategy 인터페이스를 생성
2. MoveStrategy를 구현하는 클래스에서 move()를 정의
(move의 로직을 다르게 하기 위해 클래스를 여러개 생성해도 ok)
3. 이후 필요한 move()를 선언한 클래스를 사용

## 템플릿/콜백이란?

전략 패턴과 익명 내부 클래스를 활용한 방식이다. 전략 패턴의 컨텍스트를 템플릿, 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 한다. 로직이 담긴 콜백 오브젝트를 템플릿에 전달하면 템플릿은 해당 콜백 오브젝트의 로직을 호출한다. 호출된 로직이 반환해준 값을 이용해 템플릿은 템플릿 내부의 나머지 로직을 수행하고 최종 결과를 클라이언트에게 전달한다. 대표적으로 Spring의 JdbcTemplate이 해당 패턴을 도입해 만들어졌다.

## 제네릭을 콜백에서 활용하는법

반환 결과 타입을 다양하게 받고싶을 때 사용한다.

```java
public interface TestCallback<T> {
  T execute(String value1, T value2);
}
```