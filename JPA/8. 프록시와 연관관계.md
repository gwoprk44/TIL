---
aliases:
  - JPA
tags:
  - Resource
  - Dev
  - JPA
---

**엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다. 연관관계의 엔티티는 비즈니스 로직에 따라 사용될 때도 있지만 그렇지 않을 때도 있다.**
### 프록시
#### 프록시 특징
- 실제 클래스를 상속 받아서 만들어짐.
- 실제 클래스와 겉 모양이 같다.
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨(이론상)
- 프록시 객체는 실제 객체의 참조(target)를 보관
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출  
    ![](https://user-images.githubusercontent.com/66157892/148494907-e651c2c0-8e32-4ca2-9c4d-51424534f8ef.PNG)
- **프록시 초기화**  
    ![](https://user-images.githubusercontent.com/66157892/148494876-ba2a2a4f-97e6-4609-ab69-e2e561bd40f1.png)
- 프록시 객체는 처음 사용할 때 한 번만 초기화
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초
- 기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
- 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비  
    교 실패, 대신 instance of 사용)
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해  
    도 실제 엔티티 반환

### 지연 로딩

#### Member를 조회할 때 Team도 함께 조회해야 할까?

#### 지연 로딩 LAZY을 사용해서 프록시로 조회

```JAVA
@Entity
public class Member {
    @Id
    @GeneratedValue
    private Long id;
    @Column(name = "USERNAME")
    private String name;
    @ManyToOne(fetch = FetchType.LAZY) //**
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    ..
}
```

- 지연로딩을 활용한 프록시 조회  
    ![](https://user-images.githubusercontent.com/66157892/148495248-ff6a0aa6-e831-475d-8088-542d5baca7e4.PNG)

#### 지연 로딩 활용
- 모든 연관관계에 지연 로딩을 사용해라!
- 실무에서 즉시 로딩을 사용하지 마라!
- JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라!

### 즉시 로딩
#### Member와 Team을 자주 함께 사용한다면?

```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    private Long id;
    @Column(name = "USERNAME")
    private String name;
    @ManyToOne(fetch = FetchType.EAGER) //**
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    ..
}
```

- 즉시로딩을 통해 조회  
    ![](https://user-images.githubusercontent.com/66157892/148495471-9796bbed-3703-4504-920c-c8050fe2f2c5.PNG)

#### 프록시와 즉시로딩 주의
- 가급적 지연 로딩만 사용(특히 실무에서)
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.
- @ManyToOne, @OneToOne은 기본이 즉시 로딩 -> LAZY로 설정
- @OneToMany, @ManyToMany는 기본이 지연 로딩

### 영속성 전이: CASCADE
- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들도 싶을 때 (예: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.)  
    ![](https://user-images.githubusercontent.com/66157892/148495894-4306eef3-1101-4358-ba22-142a9c63b903.PNG)

#### CASCADE 의 종류
- ALL: 모두 적용
- PERSIST: 영속
- REMOVE: 삭제
- MERGE: 병합
- REFRESH: REFRESH
- DETACH: DETACH

##### 영속성 전이 주의
- 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음
- 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함  
    을 제공할 뿐

### 고아 객체
- 고아 객체 제거: 부모 엔티티와 연관관계가 끊어진 자식 엔티티  
    를 자동으로 삭제
- orphanRemoval = true  
    

```java
@Entity
public class Parent {
@Id @GeneratedValue
private Long id;

    @OneToMany(mappedBy = "parent", orphanRemoval = true)
    private List<Child> children = new ArrayList<Child>();
    ...
}


//자식 엔티티를 컬렉션에서 제거
Parent parent1 = em.find(Parent.class, id);
parent1.getChildren().remove(0);
```

### 영속성 전이 + 고아 객체, 생명주기
- CascadeType.ALL + orphanRemoval = true를 동시에 사용하면 어떻게 될까?  
    일반적으로 엔티티는 EntityManager.persist()를 통해 영속화되고 EntityManager.remove()를 통해 제거된다. 이것은 엔티티 스스로 생명주기를 관리한다는 뜻이다. 그런데 두 옵션을 모두 활성화하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있다.  
    영속성 전이는 DDD의 Aggregate Root개념을 구현할 때 사용하면 편리하다