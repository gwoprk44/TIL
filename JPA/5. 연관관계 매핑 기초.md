---
aliases:
  - JPA
tags:
  - Resource
  - Dev
  - JPA
---



**객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다**

- 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다.
- 객체는 참조를 사용해서 연관된 객체를 찾는다.
- 테이블과 객체 사이에는 이런 큰 간격이 있다.

### 객체 연관관계와 테이블 연관관계의 가장 큰 차이

- 참조를 통한 연관관계는 언제나 단방향이다. 객체간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 한다. 하지만 정확히 이야기하면 이것은 양방향 관계가 아니라 서로 다른 단방향 관계 2개다.

### 단방향 연관관계

```java
@Entity
public class Member {
    @Id
    @Column(name = "MEMBER_ID")
    private String id;
    private String username;

    //연관관계 매핑
    @ManyToOne
    @JoinColumn(name="TEAM_ID")
    private Team team;
    
    //연관관계 설정
    public void setTeam(Team team) {
        this.team = team;
    }
    //Getter, Setter ...
}

@Entity
public class Team {
@Id
@Column (name = "TEAM_ID")
private String id;

    private String name;
    //Getter, Setter ...
}
```

- @JoinColumn은 외래 키를 매핑할 때 사용한다.
- @ManyToOne 어노테이션은 다대일 관계에서 사용한다.

### 양방향 연관관계

```java
@Entity
public class Member {
    @Id
    @Column (name = ”MEMBER_ID”)
    private String id;
    private String username;
    
    @ManyToOne
    @JoinColumn(name="TEAM_ID H)
    private Team team;
    
    //연관관계 :설정
    public void setTeam(Team team) {
    this.team = team;
    }
    //Getter, Setter ...  
}

@Entity
public class Team {
    @Id
    @Column(name = ”TEAM_ID”)
    private String id;
    
    private String name;
    
    //==추가==//
    @OneToMany (mappedBy = "team")
    private List<Member> members = new ArrayList<Member> () ;
    
    ...
}
```

### 연관관계의 주인

<b>@OneToMany만 있으면 되지 mappedBy는 왜 필요할까?</b>

- 객체에는 양방향 연관관계라는 것이 없다. 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다.
- 연관관계의 주인은 외래 키가 있는 곳