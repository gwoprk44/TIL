---
aliases:
  - HTTP
tags:
  - Resource
  - CS
  - HTTP
---

# SQ3R

## HTTP 엔터티??

메시지의 실질적인 내용을 의미한다.

엔터티 헤더와 엔터티 본문으로 이루어져 있다.

## Content-Type 헤더 필드

엔터티 본문의 MIME 타입을 기술한다. 이를통해 엔터티가 콘텐츠 인코딩을 거친 경우에도 Content-Type 헤더는 여전히 인코딩 전의 엔터티 본문 유형을 명시한다.

## 콘텐츠 인코딩

HTTP 애플리케이션은 때떄로 콘텐츠를 보내기전에 인코딩을 수행한다. 이러한 인코딩은 발송하는 쪽에서 콘텐츠에 적용한다.

## 전송 인코딩과 청크 인코딩

전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 `안전한 전송`을 위해 존재하였다.

청크 인코딩은 메시지를 일정한 크기의 청크 여럿으로 쪼개어 메시지를 보낸다. 이를 이용하면 메시지를 보내기 전에 전체 크기를 파악할 필요가 사라진다.

이러한 청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 서버는 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린채로 유지할 수 있다.

## 조건부 요청

클라이언트가 서버에게 자신이 갖고 있는 버전을 말해주고 검사기를 사용해 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것.

HTTP는 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라 불리는 특별한 요청을 할 수 있는 방법을 제공하는데 이는 `If-`로 시작하는 조건부 헤더에 의해 구현된다.

>신선도

서버는 Expires나 Cache-Control 헤더를 통해 클라이언트에게 얼마나 오랫동안 콘텐츠를 캐시하고 그것이 신선하다고 가정할수 있는지에 대한 정보를 제공한다.

> 검사기

약한 검사기와 강한 검사기로 구분된다. 약한 검사기는 리소스의 인스턴스를 고유하게 식별하지 못하는 경우도 있으나, 강한 검사기는 언제나 인스턴스를 고유하게 식별 가능하다.

## 범위 요청

HTTP는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다.

이러한 범위 요청을 사용하면, HTTP 클라이언트는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드를 **중단된 시점**에서 재개 가능하다.

## 델타 인코딩?

객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는, http 프로토콜의 확장.

## Content-Language 헤더

엔터티가 어떤 언어 사용자를 대상으로 하고 있는지 서술한다.

이는 꼭 텍스트 문서만을 위한것이 아니라 오디오, 동영상, 애플리케이션 즉, 어떤 종류의 미디어라도 사용이 가능하다.

이 때, `Accept-Language` 헤더를 사용하면 HTTP는 우리의 언어 제약과 선호도를 웹 서버에 전달할 수 있다.

언어태그는 하이픈으로 분리된 하나 이상의 서브 태그로 이루어져있는데,
- 첫 번째 서브태그는 주 서브태그, 표준화 된 값.
- 두 번째 서브태그는 선택적이며, 자신만의 이름 표준을 따른다.
- 세 번째 서브태그는 등록되어있지 않다.

## 웹 어플리케이션이 협상 하는 방법

### 클라이언트 주도 협상

서버에게 있어서 가장 쉬운 협상은 서버가 클라이언트의 요청을 받았을 때,

가능한 페이지의 목록을 응답으로 돌려주어 클라이언트가 보고 싶은 것을 선택하게 하는 것이다.

하지만 이 방법은 단점이 명확하다.

하나의 URL 에 대해서 여러개의 조건별 페이지가 존재한다면?

> 뭘 내려줘야 할지 모르겠더라

### 서버 주도 협상
그래서 서버가 현명한 결정을 할 수 있게 `Accept` 헤더를 활용하는 것이다.

내용 협상을 위한 헤더로는 다음과 같은 것이 있다.

|헤더|설명|
|---|---|
|Accept|서버가 어떠한 미디어 타입으로 보내도 되는지 알려준다|
|Accept-Language|어떠한 언어로 보내도 되는지 알려준다|
|Accept-Charset|어떠한 차셋으로 보내도 되는지 알려준다|
|Accept-Encoding|어떠한 인코딩으로 보내도 되는지 알려준다|

그렇다면, `Accept` 헤더에는 꼭 하나의 타입만 명시해야 되는가?

그건 아니다. 우리에게는 **품질값(quality value, 줄여서 q값)** 을 이용해 전달할 수 있다.

```httpspec
Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0
```

### 투명 협상
투명 협상은 **클라이언트 입장에서 협상하는 중개자 프락시** 를 둠으로써.

클라이언트와 메세지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 줄이는 방법이다.

이를 도와주는 것이 바로 `Vary` Header 이다.

```
서버는 응답에 Vary 헤더를 포함시켜 중개자에게 내용 협상을 위해 어떤 헤더를 사용하고 있는지 알려준다.
```

## 트랜스 코딩

서버가 클라이언트의 요구에 맞지 않는 문서를 가지고 있다면, 적절히 변환하는 것이 바로 트랜스코딩이다.

그래서 트랜스코딩에는

- 포맷 변환: 한 포맷에서 다른 포맷으로 변환하는 작업
- 정보 합성: 문서에서 정보의 요점을 추출하는 것
- 내용 주입: 웹 문서의 양을 늘리는 방법

하지만 클라이언트의 매 요청마다 **트랜스코딩** 을 하는 것은 너무나 성능이 떨어진다.

그러니까 우리는 `cache` 를 적절히 활용해서, 미리 변환해 놓은 것을 저장하는 방법도 있으니 적절히 섞어야 한다.