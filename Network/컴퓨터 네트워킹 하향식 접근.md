# 목차
- [목차](#목차)
---

# 애플리케이션 계층
## 네트워크 애플리케이션을 만든다는 것
- TCP/UDP를 새로 구현하는 것이 아니다. 이미 존재하는 전송 계층 서비스를 소켓 API를 사용하여 앱으로 생성하는것이다.
- 내가 "개발자라면 내가 만든 애플리케이션이 전송 계층에 어떤 서비스를 요구하는가?를" 고려하여야 한다.
## 네트워크 애플리케이션 구조
- 클라이언트-서버: 항상 켜진 서버, 클라이언트가 접속하는것. 관리가 용이하지만 서버 확장비용이 높다. -> 대형 데이터센터를 생각하면됨.
- p2p: 각 호스트가 클라이언트이자 동시에 서버의 역할을 한다. 자원 확장성이 뛰어나지만, 관리 분산, NAT/보안/가변 업타임 이슈가 존재한다.
-> 토렌트
## 프로세스와 소켓
- 통신의 주체는 호스트가 아닌 프로세스이다.
- 소켓: 프로세스가 네트워크로 메시지를 주고 받는 문(interface), 전송 계층 서비스에 대한 API.
- 주소 지정: 목적지 IP주소 + 포트번호
- 서버는 보통 well-known port로 수신을 대기한다.
## 애플리케이션 계층 프로토콜
- 서로 다른 호스트가 협업하기위해서는 프로토콜이 필요하다.
- 프로토콜이 정의 하는 것
    - 메시지 타입(요청/응답)
    - 메시지 형식(필드, 순서, 인코딩)
    - 의미(각 필드가 뜻하는 바)
    - 절차(언제 무엇을 보내고 받을지)
- 공개 프로토콜 vs 독자 프로토콜
## 전송 계층이 제공 가능한 서비스(요구사항 관점)
- 신뢰성(데이터 손실/중복없이)
- 지연/타이밍(최대 지연 보장)
- 처리량(최소 대역폭 보장)
- 보안(기밀성, 무결성, 인증)
### TCP
- 연결 지향(3-way handshake), 신뢰적 전송, 흐름 및 혼잡 제어, 순서 보장
- 지연/처리량 보장은 존재하지않는다. 최대한 공정하게 전송하는것이 목표.
- 보안은 TLS(SSL)을 덧씌워 TCP위에서 제공한다.
### UDP
- 비연결, 최선형 노력, 헤더 가벼움.
- 앱이 자체적으로 손실복구/재전송/적응형 전송
- 지연 민감 및 약간의 손실 허용 -> 실시간 미디어에 적합하다.
## 체크리스트
1. 내 앱의 신뢰성/지연/처리량/보안 요구 정의
2. C/S vs P2P 구조 선택(확장성·운영복잡도 균형)
3. 애플리케이션 프로토콜 설계(메시지 포맷/흐름)
4. 소켓 API 사용(TCP/UDP 선택, 포트 바인딩/연결/타임아웃 등)
5. 필요하면 TLS/DTLS로 보안 추가
6. NAT/방화벽 통과 전략(STUN/TURN/ICE 등, P2P라면 특히)

---
# 웹과 HTTP
## 웹
- 클라이언트-서버 구조: 브라우저(클라이언트)<->웹 서버
- 리소스 식별: URL(또는 URI)로 각 객체를 지정한다. 예) `ttps://example.com/index.html.`
- HTTP의 역할: 애플리케이션 계층 요청/응답 프로토콜

## HTTP의 기본 성질
- 비상태(stateless): 서버는 각 요청 간에 클라이언트 상태를 보존하지 않는다.(세션은 쿠키 등으로 구현.)
- 애플리케이션 계층 텍스트 기반(HTTP/1.x), 메시지 헤더 + 바디.

## 연결 방식
- 비지속 연결: 객체마다 새 TCP를 연결한다. 오버헤드와 지연이 높다.
- 지속 연결(기본 in HTTP/1.1): 하나의 TCP 연결로 여러 객체를 전송한다.
  - 파이프라이닝: 여러 요청을 연속으로 보내 응답을 순차 수신.
  - HTTP/2: 하나의 연결에서 프레이밍/스트림 다중화로 HQL 문제를 완화한다.
  - HTTP/3: TCP대신 QUIC(UDP기반) 사용, 지연 및 손실 환경에서 성능을 개선.

## 요청 및 응답 메시지 형식
- 요청 라인 `METHOD SP URI SP VERSION CRLF`
  - 주요 메서드: GET, POST, HEAD, PUT, DELETE
  - 헤더 예: Host, User-Agent, Accept, Accept-Encoding, Content-Type, Content-Length, Authorization, Cookie ...
  - 바디: 메서드에 따라 존재한다.(주로 POST/PUT)
- 응답 상태 라인: VERSION SP STATUS-CODE SP REASON-PHRASE CRLF
  - 2xx 성공(200 OK, 204 No Content)
  - 3xx 리다이렉션(301/308 영구, 302/303/307 임시, Location 헤더)
  - 4xx 클라이언트 오류(400, 401 Unauthorized, 403, 404)
  - 5xx 서버 오류(500, 502, 503 Service Unavailable)

## 쿠키(Cookies)로 상태 유지
- 서버 -> 클라이언트: Set-Cookie 헤더(쿠키 ID 포함)
- 이후 요청에서 브라우저는 Cookie 헤더로 ID 전송 -> 서버가 세션/로그인 상태 식별.
- 프라이버시 및 보안: Secure, HttpOnly, SameSite 속성으로 위험 완화.

## 캐시와 프록시(웹 캐시)
- 프록시(캐시) 서버가 콘텐츠를 저장해 재사용 → 대기시간↓, 백본 트래픽↓, 서버 부하↓.
- 조건부 GET으로 신선도 확인:
  - 클라이언트: If-Modified-Since 또는 If-None-Match: <ETag>
  - 서버: 변경 없음 → 304 Not Modified로 본문 없이 응답.
- 캐시 제어 헤더: Cache-Control(max-age, no-store, no-cache), Expires, ETag, Last-Modified.

## 컨텐츠 전송 최적화
- 콘텐츠 협상: Accept-* 헤더로 포맷/언어/인코딩 협상.
- 압축: Accept-Encoding: gzip ↔ Content-Encoding: gzip → 전송량↓.
- 부분 전송: Range 요청으로 재개/스트리밍(206 Partial Content).

## 성능 및 지연 관점
- 왕복(RTT) 비용을 줄이는 지속 연결/다중화/캐시/압축/CDN이 체감 성능에 결정적이다.
- TCP Handshake/TLS 핸드셰이크 최소화가 중요(HTTP/2, HTTP/3 도입 배경).

---