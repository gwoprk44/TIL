# 목차

## 네트워크 애플리케이션의 원리

### 앱은 어떻게 통신하는가? - 두가지 구조(클라이언트-서버 vs p2p)
네트워크 앱의 구조는 크게 두 가지로 구분할 수 있다.
- 클라이언트-서버 모델: 항상 켜져서 요청을 기다리는 **서버(Server)**와 필요할 때 서비스를 요청하는 **클라이언트(Client)**로 구성된다. 마치 식당(서버)과 손님(클라이언트)의 관계와 같다. 우리가 사용하는 대부분의 웹 서비스가 이 구조다.
-  P2P (Peer-to-Peer) 모델: 중앙 서버 없이 모든 컴퓨터(피어, Peer)가 동등한 입장에서 서로 직접 통신한다. 모든 피어가 서버이자 클라이언트가 될 수 있다. 토렌트(BitTorrent)가 대표적인 예시다.

### 프로그램끼리는 어떻게 서로를 찾는가? - 주소와 문(Port)
서로 다른 컴퓨터에서 실행되는 프로그램(프로세스)끼리 통신을 하려면 서로를 찾아갈 주소가 필요하다.
- IP 주소: 네트워크에 연결된 컴퓨터(호스트)의 주소
- 포트 번호: 해당 컴퓨터 안에서 실행되고 있는 수많은 프로그램 중 특정 프로그램을 식별하는 번호.
- 통신을 위해서는 `IP주소 + 포트번호` 모두가 필요하다.

### 어떤 방식으로 데이터를 보낼것인가? - TCP vs UDP
애플리케이션의 특성에 따라 데이터를 보내는 방식(전송 프로토콜)을 결정해야 한다.

#### TCP
- 특징: 신뢰성과 순서 보장
- 동작:
  - 상대방과의 연결을 확인(3-way handshake)
  - 데이터를 순서대로 전송하며, 잘 받았는지 확인
  - 데이터가 중간에 유실되면 재전송.
- 장점: 데이터가 정확히 전송됨을 보장.
- 단점: 확인 절차 때문에 UDP보다 느림.
- 사용 예: 웹 브라우징, 파일 전송, 이메일 등 데이터의 정확성이 요구되는 부분.

#### UDP
- 특징: 빠른 속도.
- 동작.
  - 연결 확인절차 없이 데이터를 전송.
  - 데이터가 중간에 유실되거나 순서가 바뀌어도 신경쓰지않는다.
- 장점: 매우 빠르고 효율적.
- 단점: 데이터 전송을 보장하지 않는다(비신뢰).
- 사용 예: 온라인 게임, 실시간 영상 스트리밍 등.

우리가 사용하는 인터넷 앱은 클라이언트-서버 또는 P2P 구조를 가지며, IP와 포트를 이용해 통신 대상을 찾는다. 그리고 앱의 성격에 따라 신뢰성이 중요한 TCP를 쓸지, 속도가 중요한 UDP를 쓸지 결정하는 것이다. 이 간단한 원리가 복잡한 네트워크의 시작점이다.

---

## 웹과 HTTP

### 웹 통신은 기본적으로 '단기 기억 상실증'
HTTP는 기본적으로 비상태(Statelss)를 유지한다. 서버는 방금 요청한 클라이언트가 누구인지 기억하지 않는다. 매번 당신은 누구십니까? 하고 묻는것과 같다.
- 장점: 서버가 클라이언트 정보를 저장할 필요가없어 구조가 단순하고 확장이 용이하다.
- 단점: 로그인을 유지하거나 장바구니에 물건을 담는 것처럼 상태 유지가 필요할땐 문제가 된다.

### 서버는 날 어떻게 알아보는가? - 쿠키(Cookies) 사용
서버가 나(클라이언트)를 기억하게 하는 방법이 바로 쿠키이다.
1. 서버: 클라이언트가 처음 접속했을 때, 나를 식별할 수 있는 작은 표식을 응답 메시지에 담아 보낸다(Set-Cookie 헤더)
2. 클라이언트 브라우저: 그 표식(쿠키)를 보관한다.
3. 클라이언트: 이후 그 서버에 요청할 때마다 보관해둔 표식을 항상 같이 보낸다.(Cookie 헤더)
결국, 서버는 이 표식을 보고 클라이언트를 알아본다.

### 통신에도 효율이 존재 - 비지속 연결 vs 지속 연결
웹 페이지 하나에는 HTML 파일, 여러 개의 이미지 파일, CSS 파일 등 수많은 '객체'가 있다. 이것들을 어떻게 가져오느냐에 따라 속도가 달라진다.
- 비지속 연결 (옛날 방식, HTTP/1.0): 객체 하나 가져올 때마다 TCP 연결을 새로 맺고 끊는다. 이미지 10개면 연결도 10번! 매우 비효율적이다.
- 지속 연결 (요즘 방식, HTTP/1.1): TCP 연결을 한번 맺으면, 그 연결을 통해 여러 객체를 한꺼번에 요청하고 받는다. 전화 한 번 걸어서 모든 용건을 말하는 것과 같아서 훨씬 빠르다.

### 웹 통신의 언어 - HTTP 메시지
브라우저(클라이언트)와 서버는 정해진 양식의 메시지를 주고받는다.
- 요청 메시지 (클라이언트 → 서버): "저기요, 이 페이지 좀 주세요!"
  - GET /index.html HTTP/1.1: GET(가져와줘), /index.html(이 파일을), HTTP/1.1(이 버전으로)
  - 헤더: Host(어느 서버인지), User-Agent(내 브라우저 정보) 등 부가 정보
- 응답 메시지 (서버 → 클라이언트): "네, 여기 있습니다!" 또는 "없는데요?"
  - HTTP/1.1 200 OK: HTTP/1.1(이 버전으로), 200 OK(성공적으로 처리했어!)
  - 헤더: Content-Type(이 파일은 HTML이야), Content-Length(파일 크기) 등 부가 정보
  - 본문(Body): 실제 HTML 파일 데이터

💡주요 상태 코드
- 200 OK: 성공!
- 301 Moved Permanently: 이사 갔으니 저쪽 주소로 다시 요청해.
- 404 Not Found: 요청한 파일 여기 없어. (우리가 흔히 보는 그 페이지!)
- 500 Internal Server Error: 미안, 내 서버에 문제가 생겼어.

### 더 빠르게 만드는 기술 - 웹 캐시(Web Cache)
자주 가는 동네 도서관이 존재한다면, 멀리 있는 중앙 도서관까지 갈 필요가 없는 것처럼. 웹 캐시가 동네 도서관 역할을 한다.
- 클라이언트가 이미지 하나를 요청하면, 웹 캐시 서버가 원본 서버로부터 이미지를 받아 나에게 주면서 자신도 한 부 복사해둔다.
- 다음에 클라이언트가 같은 이미지를 또 요청하면, 웹 캐시는 원본 서버까지 가지 않고 자신이 저장 해둔 복사본을 바로 클라이언트에게 전달한다. -> 속도가 훨씬 빠르다.

웹 통신(HTTP)은 기본적으로 기억력이 없는 '비상태' 프로토콜이지만, '쿠키'를 통해 사용자를 식별한다. 오늘날 웹이 빠른 이유는 한 번의 연결로 여러 데이터를 주고받는 '지속 연결'과, 자주 쓰는 데이터를 가까운 곳에 저장해두는 '웹 캐시' 덕분이다.

---

## 인터넷 전자메일

### 이메일 시스템의 세 가지 핵심 요소
이메일이 동작하기 위해서는 세 가지 핵심 요소가 필요하다.
1. 사용자 에이전트(User Agent): 우리가 직접 사용하는 프로그램(아웃록, 메일 앱, 웹 메일 등) 메일을 작성하고, 읽고, 관리하는 역할.
2. 메일 서버(Mail Server): 이메일 시스템의 핵심. 24시간 동작하며 사용자를 대신하여 이메일을 주고받고 보관하는 우체국 같은 존재. 모든 사용자는 자신만의 메일함(mailbox)을 이 서버에 가지고있다.
3. SMTP (Simple Mail Transfer Protocol): 메일을 '보낼 때(Push)' 사용하는 프로토콜(규칙). 내가 작성한 메일을 내 메일 서버로 보내고, 내 메일 서버가 상대방 메일 서버로 전달할 때 사용된다.

### 이메일 전송 과정
1. 작성: 사용자 에이전트에서 메일을 작성한다.
2. 전송: 전송 버튼을 누르면 SMTP를 통해 내 메일이 내 소속 메일 서버로 보내진다.
3. 서버 간 전달: 서버는 주소를 확인하고, 상대방 메일 서버를 찾아 SMTP를 이용하여 메일을 전달한다. 이 때 TCP를 이용하여 신뢰성있는 전송을 한다.
4. 보관: 상대방 서버는 전달받은 메일을 메일함에 보관한다.

>💡 핵심 포인트: 메일을 보낼 때, 즉 '밀어넣을(Push)' 때는 처음부터 끝까지 SMTP가 사용된다. 하지만 SMTP는 7비트 ASCII 문자만 전송할 수 있어서 이미지나 영상 같은 파일은 **MIME(Multipurpose Internet Mail Extensions)**라는 표준에 따라 텍스트로 변환(인코딩)되어 전송된다.

### 메일 확인하기: 두 가지 방법 (POP3 vs IMAP)
상대방 메일함에 도착한 메일을 내가 확인(가져오기, Pull)할 때는 다른 프로토콜이 필요하다. SMTP는 보내기 전용이기 때문이다. 이때 사용하는 대표적인 두 가지 방식이 있다.

- POP3 (Post Office Protocol - version 3): '다운로드 후 삭제' 모델.
  - 동작: 메일 서버에 접속해서 모든 메일을 내 PC(사용자 에이전트)로 다운로드 한 후, 서버에서는 메일을 삭제하는 것이 기본 동작.(서버에 메시지 저장본을 저장하는 옵션도 존재한다.)
  - 특징: 한 번 다운로드하면 오프라인 상태에서도 메일 읽기가 가능하다. 여러 기기에서 메일을 확인하면 동기화가 되지않아 불편하다.
- IMAP (Internet Message Access Protocol): '원격 서버 관리' 모델.
  - 동작: 모든 메일을 서버에 그대로 두고, 내가 필요할 때마다 서버에 접속하여 확인만 하는 방식. 메일을 읽거나, 폴더를 생성하거나, 삭제하는 모든 작업이 서버에 직접 반영된다.
  - 특징: 스마트폰, PC, 태블릿 등 어떤 기기에서 접속하든 항상 동일한 메일 상태가 유지된다. 지메일, 네이버 메일 등 대다수의 웹 메일 서비스가 이방식을 사용한다.

---

## DNS: 인터넷의 디렉토리 서비스

### 왜 DNS가 필요한것인가?
사람은 이름`(google.com)`을 기억하기 쉽고. 컴퓨터는 숫자(IP)를 처리하기 쉽기 때문이다. DNS는 이 둘 사이를 변환해주는 필수적인 중개자 역할을 한다. 만약 DNS가 없다면 우리는 모든 웹 사이트의 IP주소를 외워야 했을 것이다.

### DNS는 하나의 거대한 서비스가 아니다(분산 계층 구조)
DNS 서버는 전 세계에 흩어져 있는 수많은 서버들이 계층을 이루어 협력하는 분산 시스템이다. 마치 거대한 회사의 조직도와 같다.

1. 루트 DNS 서버: 전 세계에 단 13개의 논리적 그룹만 존재하는 상위. `.`을 관리하며 `.com`, `.kr`은 저기로 가라고 알려주는 안내원 역할을 한다.
2. 최상위 도메인(TLD)서버: `.com`, `.org`, `.net`, `.kr` 등 도메인 종류별 담당자. `google.com`에 대해 물으면, `'google'`을 담당하는 서버가 어디 있는지 알려준다.
3. 책임 DNS 서버 (Authoritative DNS Server): `google.com`, `naver.com` 등 실제 개별 도메인의 '진짜' IP 주소 정보를 가지고 있는 최종 담당자. 

### 주소를 찾아가는 여정(DNS Query)
컴퓨터가 `www.google.com`의 IP의 주소를 알아내는 과정은 매우 체계적이다.
1. 첫 번째 질문 (내 PC → 로컬 DNS 서버): 내 컴퓨터는 가장 먼저 ISP(KT, SKT 등)가 지정해준 로컬 DNS 서버에게 "www.google.com 주소 알아?"라고 묻는다.
2. 질문 릴레이 시작 (로컬 DNS 서버의 여정): 로컬 DNS 서버가 모르면, 이제부터 직접 발로 뛰기 시작한다.
   - (→ 루트 서버): "혹시 www.google.com 아니?" / 루트: "난 몰라. 근데 .com 담당자한테 물어봐. 걔 주소는 이거야."
   - (→ .com TLD 서버): "혹시 www.google.com 아니?" / TLD: "난 몰라. 근데 google.com 담당자(책임 서버)한테 물어봐. 걔 주소는 이거야."
   - (→ google.com 책임 서버): "혹시 www.google.com 아니?" / 책임 서버: "어! 알아. 걔 IP 주소는 142.250.204.78 이야."
   - 답변 전달: 로컬 DNS 서버는 드디어 알아낸 IP 주소를 내 컴퓨터에게 알려준다.

### DNS가 빠른 이유 - 똑똑한 캐싱
매번 우리가 인터넷을 이용할 때 위와같은 과정을 거치면 인터넷 활동이 너무 느릴것이다. 이를 해결하기 위해 바로 DNS는 캐싱을 활용한다.
- 한 번 조회했던 주소 정보는 로컬 DNS 서버가 일정 시간 동안 기억(캐시)한다.
- 만약 내가 조금 전에 접속했던 `google.com`을 다시 요청하면, 로컬 DNS 서버는 저 복잡한 과정을 또 거치지 않고 자기가 기억해둔 IP 주소를 바로 알려준다. 덕분에 속도가 엄청나게 빨라진다.

### 전화번호부 그 이상의 기능 (DNS 레코드)
DNS는 IP 주소만 알려주는 것이 아니라, 다른 정보들도 가지고 있다.
- A 레코드: 도메인 이름 → IPv4 주소 (가장 기본)
- MX 레코드: 메일 서버 주소. `user@example.com`으로 메일을 보낼 때, `example.com`의 메일 서버(SMTP 서버)가 어디인지를 알려준다. (2.3장에서 배운 이메일과 연결되는 부분!)
- CNAME 레코드: 별명. `www.example.com`을 `example.com`의 별명으로 지정할 수 있다.