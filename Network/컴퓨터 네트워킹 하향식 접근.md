# 목차

# 컴퓨터 네트워크 애플리케이션 원리

## 네트워크 애플리케이션 구조
애플리케이션 개발자는 애프리케이션이 다른 종단 시스템에서 어떻게 실행되고 통신할지 구조를 결정해야한다. 크게 두 가지 주류 구조가 존재.

### 클라이언트-서버 구조
- 서버: 항상 켜저있는 호스트. 고정 ip 주소를 가지며, 거대한 데이터 센터에의해 지원되기도 한다.
- 클라이언트: 서버와 통신하는 호스트. 간헐적으로 연결되며 유동 ip르 가진다. 클라이언트끼리는 직접 통신x
- 예시: 웹(HTTP), 이메일(SMTP), FTP 등

### P2P 구조
- 항상 켜저 있는 인프라 서버에 의존하지 않는다.
- 피어(Peer): 간헐적으로 연결되는 호스트 쌍이 서로 직접 통신.
- 자가 확장성: 새로운 피어가 들어오면 작업 부하도 늘어나지만, 서비스 능력(파일 분배)도 같이 늘어난다.
- 단점: 관리가 어렵고, 보안 및 신뢰성 확보가 복잡하다
- 예시: 비트토렌트, 스카이프 등

## 프로세스 간 통신
운영체제 관점에서 실제 통신하는 것은 프로그램이 아니라 프로세스이다.
- 클라이언트 프로세스: 통신을 시작하는 프로세스.
- 서버 프로세스: 접속을 기다리는 프로세스.
- P2P 구조에서도 파일을 다운로드 하는 쪽이 클라이언트, 파일을 업로드 하는 쪽이 서버 역할을 한다.

### 소켓(Socket)
- 애플리케이션 계층과 전송 계층 사이의 인터페이스(API)
- 비유: 프로세스는 집, 소켓은 문. 프로세스는 문 밖으로 메시지를 보내고, 전송 계층이 목적지의 문까지 배달.
- 애플리에키션 개발자는 소켓의 애플리케이션 쪽만 제어 가능하며, 전송 계층 쪽은 거의 제어할 수 없다(프로토콜의 선택, 파라미터 설정 정도만 가능)

## 프로세스 주소 지정
메시지를 보내기 위해 수신 프로세스를 식별해야 한다. 두 가지 정보가 필요.
1. 호스트의 주소(IP Adress): 네트워크 상에서 컴퓨터(호스트)를 식별.
2. 포트 번호(Port Number): 호스트 내에서 특정 프로세스(애플리케이션)을 식별.(80, 25, 22 등)

## 애플리케이션이 필요로 하는 전송 서비스
애플리케이션마다 전송 계층에 요구하는 서비스의 종류가 다르다.

1. 신뢰할 수 있는 데이터 전송: 데이터 손실 없이 100% 전송 보장.(이메일, 파일 전송 등)
2. 처리량: 일정 수준 이상의 대역폭 보장.(멀티미디어 스트리밍 등)
3. 시간: 패킷 도착 지연시간(Latency) 보장.(실시간 게임, 인터넷 전화 등)
4. 보안: 데이터 암호화 및 무결성.

## 인터넷 전송 프로토콜(TCP vs UDP)
인터넷(TCP/IP 네트워크)는 애플리케이션에게 두 가지 전송 프로토콜을 제공.

### TCP 서비스
- 연결 지향형: 통신 전 핸드 셰이킹 진행.
- 신뢰적 데이터 전송: 데이터 손실 없음, 순서 보장
- 혼잡 제어: 네트워크가 혼잡하면 전송 속도를 조절(전체 네트워크를 위함)
- 젲공하지 않는 것: 최소 처리량 보장, 시간(지연) 보장, 보안

> 참고: TCP 자체는 보안을 제공하지 않으므로, 애플리케이션 계층에서 SSL/TLS등을 사용하여 TCP 강화.

### UDP 서비스
- 비연결형: 핸드셰이킹 없음.
- 비신뢰적 데이터 전송: 데이터 손실 가능, 순서 뒤바뀜 가능
- 특징: 오버헤드가 적고 빠르다. 혼잡 제어를 하지 않아 원하는 속도로 데이터를 밀어넣는것이 가능.
- 주로 사용하는 곳: 실시간 멀티미디어, DNS 등

## 애플리케이션 계층 프로토콜
다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 메시지를 교환하는 방식 정의.
- 정의하는 내용:
  - 메시지 타입(요청 vs 응답)
  - 메시지 문법(필드 구성)
  - 메시지 의미(필드 정보의 뜻)
  - 프로세스가 메시지를 언제, 어떻게 보내고 응답하는지에 대한 규칙
- 종류:
  - 오픈 프로토콜(RFC 정의): HTTP, SMTP(상호 운용성 보장)
  - 독점 프로토콜: Skype, Zoom 등(해당 회사 제품끼리만 통신)

💡 오늘의 회고 (Reflection)
- 소켓의 역할: 소켓이 단순한 연결 통로가 아니라, 애플리케이션 계층과 전송 계층을 나누는 '문(Door)' 역할을 한다는 비유가 인상적이었다. 개발자는 문 안쪽(앱)만 신경 쓰고, 문 밖(네트워크)은 OS와 프로토콜에 맡긴다는 점이 추상화의 핵심인 것 같다.
- TCP의 한계: TCP가 신뢰성은 보장하지만, '시간'이나 '대역폭'을 보장해주지는 않는다는 점을 다시 확인했다. 실시간 서비스가 왜 UDP를 고려하거나 별도의 최적화를 하는지 이해가 된다.
- P2P의 자가 확장성: 사용자가 늘어나면 서버 비용이 기하급수적으로 느는 클라이언트-서버 구조와 달리, P2P는 사용자가 곧 서버 역할을 일부 수행하므로 확장에 유리하다는 점이 흥미롭다.

---

# 웹과 HTTP

## HTTP 개요
웹의 애플리케이션 계층 프로토콜인 HTTP는 웹의 중심.

- 구성
  - 웹 페이지: 객체 들로 구성. 기본 HTML 파일과 그 안에서 참조되는 여러 객체(이미지, CSS, JS 파일 등)이 존재.
  - URL: 각 객체는 URL(호스트 이름 + 경로 이름)로 주소가 지정.
- 동작 방식: 클라이언트(브라우저)와 서버(웹 서버)간의 통신. TCP를 전송 프로토콜로 사용(80 포트)
- 비상태 프로토콜(Stateless Protocol):
  - 서버는 클라이언트의 과거 요청에 대한 정보를 저장x
  - 이유: 상태를 유지하려면 서버 구조가 복잡해지고, 서버 장애 시 상태 복구가 어렵기 때문이다.

## 비지속 연결과 지속 연결
HTTP가 TCP 연결을 어떻게 사용하는지에 대한 구분

### 비지속 연결
- 방식: 각 객체(파일)을 전송할 때마다 새로운 TCP 연결을 맺고 끊는다.(HTTP/1.0)
- 단점:
  - 매번 TCP 핸드셰이킹이 필요해 오버헤드가 큼.
  - RTT: 패킷이 왕복하는 시간. 객체 하나당 최소 2RTT + 전송 시간 소요.

### 지속 연결
- 방식: 하나의 TCP 연결을 매즌 후, 일정 시간 동안 연결을 유지하며 어러 객체를 연속해서 보낸다.(HTTP/1.1의 기본)
- 장점: 핸드셰이킹 비용이 줄어들고, 응답 속도가 빨라진다.

## HTTP 메시지 포맷
사람이 읽을 수 있는 텍스트 형태.

### 요청 메시지
- 요청 라인 (Request line): `GET /index.html HTTP/1.1` (메서드, URL, 버전)
  - 주요 메서드:
    - GET: 객체 요청시 사용
    - POST: 폼 입력 데이터 등을 서버로 보낼때 사용(엔티티 바디에 데이터 포함)
    - HEAD: GET과 같지만 객체는 빼고 헤더만 요청(디버깅, 캐시 확인용)
    - PUT: 경로에 지정된 파일로 내용을 업로드/대체.
- 헤더 라인 (Header lines): Host, User-Agent, Connection 등 부가 정보

### 응답 메시지
- 상태 라인: 프로토콜 버전, 상태 코드, 상태 메시지
- 주요 상태 코드:
  - 200 OK: 요청 성공.
  - 301 Moved Permanently: 객체가 새 URL로 이동함.
  - 400 Bad Request: 서버가 요청을 이해 못 함.
  - 404 Not Found: 요청한 문서가 없음.
  - 505 HTTP Version Not Supported: 해당 버전 지원 안 함.

## 쿠키 (Cookies) - 상태 유지 기술
HTTP는 Stateless지만, 실제 서비스(쇼핑카트, 로그인 등)는 사용자를 식별해야 한다. 이를 위해 쿠키를 사용한다.

1. 동작 원리:
   - 서버가 응답 헤더에 Set-cookie: 번호를 포함.
   - 클라이언트는 브라우저에 쿠키를 저장.
   - 이후 요청마다 Cookie: 번호 헤더를 포함해서 보냄.
2. 구성 요소:
   - HTTP 응답/요청 메시지의 쿠키 헤더.
   - 클라이언트 종단 시스템의 쿠키 파일.
   - 웹 서버의 백엔드 데이터베이스.

## 웹 캐싱 
프록시 서버(Proxy Server)라고도 하며, 기원 웹 서버(Origin Server)를 대신해 HTTP 요청을 처리한다.

- 목적:
  - 클라이언트 요청의 응답 시간 단축.
  - 기관의 접속 링크(Access Link) 트래픽 감소.
- 동작: 브라우저는 프록시 서버에 먼저 요청 -> 프록시에 객체가 있으면 반환 -> 없으면 프록시가 기원 서버에 요청해서 받아온 뒤 클라이언트에 전달(하고 저장).
- 조건부 GET (Conditional GET):
  - 캐시된 데이터가 최신인지 확인하는 메커니즘.
  - 요청: `If-Modified-Since: <date>`
  - 응답: 변경이 없으면 `304 Not Modified` (바디 없이 헤더만 보내서 대역폭 절약).

## HTTP/2와 HTTP/3 (진화)

HTTP/1.1의 성능 문제를 해결하기 위해 등장했다.

- HTTP/1.1의 문제 (HOL Blocking): 하나의 큰 객체가 앞서 전송되면 뒤의 작은 객체들이 기다려야 하는 문제(Head-of-Line Blocking).
- HTTP/2:
  - 하나의 TCP 연결 안에서 요청/응답을 프레임(Frame) 단위로 쪼개서 멀티플렉싱(Interleaving) 전송.
  - 우선순위 지정, 서버 푸시(Server Push) 기능 등.
  - 여전한 문제: TCP 레벨에서의 패킷 손실이 발생하면 전체 스트림이 지연됨(TCP HOL Blocking).
- HTTP/3:
  - TCP 대신 UDP 기반의 QUIC 프로토콜 사용.
  - 전송 계층에서의 HOL Blocking 문제까지 해결.

💡 오늘의 회고 (Reflection)

- Stateless와 Cookie의 관계: HTTP 설계 철학은 '단순함(Stateless)'이지만, 현실의 요구사항(로그인 등)을 반영하기 위해 '쿠키'라는 덧붙임 기술을 사용한다는 점이 흥미롭다.
- 캐싱의 중요성: 웹 캐싱(프록시)이 단순히 속도만 빠르게 하는 게 아니라, 전체 네트워크 트래픽 비용을 줄여주는 핵심 인프라라는 것을 알게 되었다. 304 Not Modified 응답이 얼마나 효율적인지 깨달음.
- 프로토콜의 진화: HTTP/1.1 -> 2 -> 3으로 넘어가는 과정이 결국 "병목 현상(Blocking)을 어떻게 없앨 것인가"에 대한 투쟁의 역사 같다.

---

# 인터넷 전자메일

## 전자메일 시스템의 3대 구성요소
인터넷 메일 시스템은 크게 세 가지 주요 요소로 구성된다.

1.  **사용자 에이전트 (User Agents):**
    *   사용자가 메일을 읽고, 작성하고, 보내는 프로그램.
    *   *예: Outlook, Apple Mail, 웹 브라우저(Gmail 등)*
2.  **메일 서버 (Mail Servers):**
    *   메일 인프라의 핵심.
    *   **메일박스 (Mailbox):** 수신된 메일을 저장하는 공간.
    *   **메시지 큐 (Message Queue):** 전송을 기다리는 메일들이 대기하는 공간. (전송 실패 시 재시도 처리)
3.  **SMTP (Simple Mail Transfer Protocol):**
    *   메일 서버 간에 메일을 전송하거나, 사용자 에이전트가 메일 서버로 메일을 보낼 때 사용하는 프로토콜.



## SMTP (Simple Mail Transfer Protocol)
*   **특징:**
    *   **TCP 사용:** 포트 25번. 신뢰적인 데이터 전송을 보장한다.
    *   **푸시 프로토콜 (Push Protocol):** 송신 측이 수신 측으로 메시지를 밀어넣는다. (↔ HTTP는주로 풀(Pull) 방식)
    *   **직접 전송:** 송신 서버에서 수신 서버로 직접 보낸다 (중간 서버를 거치지 않음).
    *   **지속 연결 (Persistent Connection):** 한 번의 TCP 연결로 여러 개의 메일을 보낼 수 있다.
*   **제약 사항:**
    *   모든 메시지 본문은 **7-bit ASCII**여야 한다. (따라서 이진 파일은 인코딩 변환이 필요함)

### SMTP 통신 과정 예시
1.  **핸드셰이킹:** 클라이언트(송신 서버)가 TCP 연결 후 `HELO` 명령으로 자신을 소개.
2.  **메시지 전송:**
    *   `MAIL FROM: <...>` (보내는 사람)
    *   `RCPT TO: <...>` (받는 사람)
    *   `DATA` (본문 시작)
    *   메시지 끝은 `.` (점 하나)만 있는 줄로 표시.
3.  **종료:** `QUIT` 명령으로 연결 해제.

## 메일 메시지 포맷과 MIME
SMTP 명령(Envelope)과 실제 메일 내용(Message)은 분리되어 있다.

*   **헤더 (Header):** `To:`, `From:`, `Subject:` 등의 정보. (본문과 빈 줄로 구분됨)
*   **바디 (Body):** 실제 메시지 내용.
*   **MIME (Multipurpose Internet Mail Extensions):**
    *   SMTP는 7-bit ASCII만 지원하므로, 한글이나 이미지/동영상 같은 **이진 데이터(Non-ASCII)**를 전송하기 위해 개발된 확장 프로토콜.
    *   헤더에 `Content-Type`, `Content-Transfer-Encoding` 등을 명시하여 데이터를 인코딩해서 보낸다.

## 메일 접속 프로토콜 (Mail Access Protocols)
SMTP는 **'보내는(Push)'** 프로토콜이다. 수신자(밥)가 자신의 메일 서버에서 메일을 **'가져오는(Pull)'** 데에는 다른 프로토콜이 필요하다.

### A. POP3 (Post Office Protocol version 3)
*   **아주 단순함.** 포트 110 사용.
*   **진행:** 인증(로그인) -> 트랜잭션(메일 가져오기) -> 업데이트(삭제 등).
*   **모드:**
    *   **Download-and-delete:** 메일을 PC로 가져오고 서버에서 삭제. (다른 기기에서 확인 불가)
    *   **Download-and-keep:** 서버에 복사본 유지.
*   **특징:** 세션 간 상태 정보를 유지하지 않음(Stateless). 폴더 관리 기능이 미약함.

### B. IMAP (Internet Mail Access Protocol)
*   **복잡함.** 포트 143 사용.
*   **특징:**
    *   메일을 서버에 유지하며 폴더(디렉터리) 구조로 관리 가능.
    *   메시지의 상태(읽음, 답장함 등)를 서버가 기억함.
    *   **여러 기기 동기화**에 최적화되어 있음.

### C. 웹 기반 이메일 (HTTP)
*   오늘날 가장 많이 사용되는 방식 (Gmail, Outlook.com 등).
*   **송신자 ↔ 송신자 메일 서버:** HTTP
*   **송신자 메일 서버 ↔ 수신자 메일 서버:** SMTP (서버 간 이동은 여전히 SMTP)
*   **수신자 메일 서버 ↔ 수신자:** HTTP

## HTTP vs SMTP 비교
*   **공통점:** 둘 다 한 호스트에서 다른 호스트로 파일을 전송함. 지속 연결(Persistent connection)을 사용함.
*   **차이점:**
    1.  **방식:** HTTP는 **Pull** (사용자가 서버에서 긁어옴), SMTP는 **Push** (보내는 쪽이 밀어넣음).
    2.  **객체 캡슐화:**
        *   HTTP는 각 객체(이미지 등)를 별도의 응답 메시지로 보냄.
        *   SMTP는 모든 객체를 하나의 멀티파트(Multipart) 메시지로 합쳐서 보냄.

### 💡 오늘의 회고 (Reflection)
*   **SMTP의 장수 비결:** 1982년에 정의된 아주 오래된 프로토콜인데도, 7-bit ASCII라는 제약사항을 MIME으로 극복하며 여전히 전 세계 메일 시스템의 뼈대 역할을 한다는 점이 놀랍다. 기술의 '하위 호환성'이 얼마나 중요한지 보여준다.
*   **Push와 Pull의 명확한 구분:** 메일을 보낼 때(SMTP)와 받을 때(POP3/IMAP/HTTP) 서로 다른 프로토콜이 필요한 이유가 'Push'와 'Pull'의 차이 때문이라는 점을 확실히 이해했다. 내가 PC를 끄고 있어도 메일 서버가 켜져 있기 때문에 메일을 받을 수 있는 것이다.
*   **IMAP의 편리함:** 요즘 스마트폰과 PC를 오가며 메일을 확인해도 읽음 처리가 동기화되는 것이 바로 IMAP(또는 HTTP API) 덕분이었다. POP3를 썼다면 정말 불편했을 것이다.
*   

---
# DNS (인터넷의 디렉터리 서비스)

## DNS (Domain Name System) 개요
사람은 `www.google.com` 같은 호스트 이름(Hostname)을 좋아하고, 라우터는 `172.217.xxx.xxx` 같은 IP 주소를 좋아한다. 이 둘을 매핑해주는 시스템이 DNS다.

*   **정의:** 호스트 이름을 IP 주소로 변환해주는 분산형 데이터베이스 시스템이자 애플리케이션 계층 프로토콜.
*   **특징:**
    *   **UDP** 위에서 실행되며 포트 **53번**을 사용한다.
    *   네트워크 코어(라우터)에 있는 것이 아니라 **네트워크 가장자리(Edge)**의 종단 시스템에서 실행된다.
*   **중앙 집중식을 피하는 이유:** 단일 실패 지점(Single point of failure), 트래픽 폭주, 거리로 인한 지연, 유지보수 문제 등을 해결하기 위해 **계층적이고 분산된 구조**를 택했다.

## DNS가 제공하는 서비스
단순히 주소 변환 외에도 추가적인 서비스를 제공한다.

1.  **호스트 이름 변환 (Hostname to IP):** 가장 기본적인 기능.
2.  **호스트 별칭 (Host Aliasing):** 복잡한 정식 호스트 이름(Canonical hostname)에 대해 기억하기 쉬운 별칭을 제공.
3.  **메일 서버 별칭 (Mail Server Aliasing):** 이메일 주소(`@google.com`)와 웹 서버(`www.google.com`)가 같은 호스트 이름을 쓰더라도, DNS가 메일 서버는 다른 곳으로 안내해준다.
4.  **부하 분산 (Load Distribution):** 인기 있는 사이트는 여러 대의 서버(IP)를 운영한다. DNS는 요청이 올 때마다 IP 주소 목록의 순서를 바꿔서(Round Robin) 트래픽을 분산시킨다.

## DNS의 계층적 구조 (Distributed Hierarchical Database)
DNS 서버는 전 세계에 계층적으로 분산되어 있다.

### A. 계층 순서
1.  **루트 DNS 서버 (Root DNS Servers):** 전 세계에 13개의 논리적 서버(실제로는 수백 개 복제)가 있다. TLD 서버의 IP를 알려준다.
2.  **최상위 도메인 (TLD) 서버 (Top-Level Domain):** `.com`, `.org`, `.kr` 같은 도메인을 관리한다. 책임 DNS 서버의 IP를 알려준다.
3.  **책임 DNS 서버 (Authoritative DNS Servers):** 실제 기관(네이버, 구글, 대학 등)이 직접 관리하며, 호스트의 실제 IP 주소를 가지고 있는 서버다.

### B. 로컬 DNS 서버 (Local DNS Server)
*   계층 구조에는 엄밀히 속하지 않지만 가장 중요하다.
*   ISP(통신사)나 기업 네트워크가 제공하는 기본 DNS 서버.
*   PC가 DNS 쿼리를 날리면 가장 먼저 **로컬 DNS 서버(프록시 역할)**로 전달된다.


## DNS 동작 원리 (Resolution)
호스트가 `www.example.com`의 IP를 물어볼 때의 과정이다.

1.  **재귀적 질의 (Recursive Query):** 호스트가 로컬 DNS에게 "IP 내놔"라고 위임하는 것. 로컬 DNS는 답을 찾아줄 의무를 짐.
2.  **반복적 질의 (Iterative Query):** 로컬 DNS가 루트 -> TLD -> 책임 서버 순으로 직접 돌아다니며 묻는 것.
    *   *루트:* "난 모르는데 .com 서버 주소는 알아. 거기가봐."
    *   *TLD:* "난 모르는데 example.com 책임 서버 주소는 알아. 거기가봐."
    *   *책임:* "어, 그 IP는 1.2.3.4야."

### DNS 캐싱 (DNS Caching)
DNS 성능의 핵심이다.
*   로컬 DNS 서버는 한 번 찾은 IP 주소 정보를 일정 시간(TTL) 동안 저장한다.
*   **효과:** TLD나 책임 서버의 IP도 캐싱하므로, 실제로는 **루트 DNS 서버까지 쿼리가 올라가는 일은 드물다.**


## DNS 레코드와 메시지
DNS는 **자원 레코드(Resource Record, RR)** 형태로 정보를 저장한다.
*   **형식:** `(Name, Value, Type, TTL)`

### 주요 Type
1.  **Type=A:** `Name`=호스트네임, `Value`=IP주소. (가장 기본)
2.  **Type=NS:** `Name`=도메인, `Value`=그 도메인의 책임 DNS 서버 호스트네임.
3.  **Type=CNAME:** `Name`=별칭, `Value`=정식 호스트네임.
4.  **Type=MX:** `Name`=별칭, `Value`=메일 서버의 정식 호스트네임.


## DNS 보안
DNS는 인터넷의 중요한 인프라이므로 공격 대상이 된다.
*   **DDoS 공격:** 루트나 TLD 서버에 트래픽을 퍼부어 마비시키려 함 (캐싱 때문에 생각보다 효과가 크지 않을 수 있음).
*   **DNS 스푸핑 (Cache Poisoning):** DNS 서버에 가짜 IP 정보를 주입하여 사용자를 피싱 사이트로 유도하는 공격.


### 💡 오늘의 회고 (Reflection)
*   **UDP를 쓰는 이유:** HTTP나 이메일은 신뢰성이 중요해서 TCP를 쓰지만, DNS는 **속도**가 가장 중요해서 UDP를 쓴다는 점이 비교가 된다. 연결 설정(Handshake) 지연조차 아까운 것이다. 실패하면 그냥 다시 물어보면 되니까.
*   **캐싱의 위대함:** 전 세계 인터넷 트래픽을 13개의 루트 서버 클러스터가 다 감당할 수 있는 이유는 결국 **로컬 DNS의 강력한 캐싱** 덕분이다. 시스템 설계에서 캐싱이 얼마나 중요한지 다시금 느낀다.
*   **계층 구조의 확장성:** 만약 DNS가 하나의 거대한 엑셀 파일(hosts.txt)이었다면 인터넷은 진작에 붕괴했을 것이다. 책임을 분산시키는(TLD, Authoritative) 계층 구조가 인터넷 확장의 일등 공신인 것 같다.

---

# P2P 파일 분배

## P2P의 핵심: 확장성 (Scalability)
이 장의 핵심 질문은 **"하나의 큰 파일을 $N$명의 사용자에게 배포할 때 얼마나 걸리는가?"**이다. 클라이언트-서버(CS) 모델과 P2P 모델을 비교하여 P2P의 자가 확장성을 증명한다.

### A. 클라이언트-서버(CS) 구조의 한계
*   서버는 파일의 복사본을 $N$명의 피어에게 각각 전송해야 한다.
*   **병목 현상:** $N$이 커질수록 서버가 전송해야 할 총 데이터 양($N \times 파일크기$)이 선형적으로 증가한다.
*   따라서 분배 시간은 $N$에 비례하여 늘어난다.

### B. P2P 구조의 자가 확장성 (Self-scalability)
*   서버는 파일을 최소 한 번만 업로드하면 된다.
*   파일을 받은 피어들이 **재분배자(Redistributor)**가 되어 자신의 업로드 대역폭을 사용해 다른 피어에게 전송한다.
*   **결과:** 새로운 피어가 들어오면 작업량(수요)도 늘지만, 전체 시스템의 **서비스 용량(업로드 대역폭)**도 같이 늘어난다.
*   $N$이 아무리 커져도 분배 시간이 거의 일정하거나 아주 완만하게 증가한다.


## 비트토렌트 (BitTorrent)
P2P 파일 공유의 가장 대표적인 프로토콜이다.

### A. 용어 및 기본 개념
*   **토렌트 (Torrent):** 특정 파일의 배포에 참여하고 있는 모든 피어들의 모임.
*   **청크 (Chunk):** 원본 파일은 256KB 크기의 작은 조각들로 쪼개진다.
*   **트래커 (Tracker):** 토렌트에 참여하는 피어들의 리스트를 관리하고, 새로 온 피어에게 다른 피어들의 IP 주소를 알려주는 인프라 서버.
*   **시더 (Seeder):** 파일 전체(모든 청크)를 가지고 있는 피어.
*   **리처 (Leecher):** 파일의 일부만 가지고 있고 다운로드 중인 피어.

### B. 동작 과정
1.  새 피어(앨리스)가 토렌트에 접속하면 트래커로부터 피어 목록(약 50명)을 받는다.
2.  앨리스는 이들과 TCP 연결을 맺고 '이웃'이 된다.
3.  시간이 지나면서 어떤 피어는 떠나고, 새로운 피어가 들어오며 이웃은 계속 바뀐다.
4.  앨리스는 이웃들에게 청크를 요청(다운로드)하는 동시에, 자신이 가진 청크를 이웃에게 제공(업로드)한다.


## 비트토렌트의 핵심 알고리즘
수많은 청크 중 무엇을 먼저 요청하고, 누구에게 데이터를 줄 것인가를 결정하는 전략이다.

### 1) 청크 선택 전략: Rarest First (가장 드문 것 먼저)
*   **문제:** 순서대로(1번, 2번...) 받으면, 특정 희귀한 청크가 없어서 완성을 못 하는 경우가 생길 수 있다.
*   **해결:** 이웃들이 가진 청크 목록을 확인하고, **가장 복사본이 적은(희귀한) 청크**를 최우선으로 요청한다.
*   **효과:** 희귀한 청크가 빠르게 복제되어 시스템 전체에 고르게 퍼지게 한다. (시더가 나가버려도 파일이 살아남을 확률을 높임)

### 2) 피어 선택 전략: Tit-for-Tat (이에는 이)
*   **문제:** 누구에게 내 업로드 대역폭을 써서 데이터를 줄 것인가? (모두에게 다 줄 순 없음)
*   **해결:**
    *   자신에게 데이터를 **가장 빠른 속도로 보내주는** 상위 4명의 이웃을 선택하여 데이터를 보내준다. (**Unchoked** 상태)
    *   이 평가는 10초마다 갱신된다. 즉, 나에게 잘해주는 사람에게 나도 보답한다(협력 유도).
*   나머지 피어들에게는 데이터를 보내지 않는다 (**Choked** 상태).

### 3) 낙관적 언초킹 (Optimistic Unchoking)
*   **문제:** 항상 상위 4명하고만 거래하면, 더 좋은 성능을 가진 새로운 피어를 발견할 수 없다.
*   **해결:**
    *   30초마다 무작위로 이웃 한 명을 선택하여 데이터를 보내본다.
    *   만약 그 이웃이 나에게 데이터를 빨리 보내줘서 상위 4등 안에 들게 되면 파트너를 교체한다.
    *   이를 통해 새로운 짝(Better Partner)을 탐색한다.

### 💡 오늘의 회고 (Reflection)
*   **협력의 기술적 구현:** 비트토렌트의 'Tit-for-Tat' 알고리즘은 게임 이론을 네트워크 프로토콜에 완벽하게 적용한 사례 같다. 이기적인 사용자(Free-rider)를 배제하고, 협력하는 사용자끼리 뭉치게 만들어 전체 성능을 높이는 설계가 훌륭하다.
*   **확장성의 마법:** 사용자 수가 늘어나면 서버가 터지는 기존 방식과 달리, 사용자가 늘어날수록 전체 전송 속도(Capacity)가 증가한다는 P2P의 수학적 원리는 대용량 파일 배포(OS 업데이트, 블록체인 등)에서 왜 P2P가 필수적인지 보여준다.
*   **Rarest First의 지혜:** 단순히 순차적으로 받는 게 아니라 '희소성'을 기준으로 우선순위를 두는 것은, 생태계의 다양성을 유지하여 전체 생존율을 높이는 자연의 섭리와도 비슷해 보인다.

---

# 비디오 스트리밍과 CDN

## 인터넷 비디오의 특징
오늘날 인터넷 트래픽의 대부분(80% 이상)은 비디오 스트리밍이다(Netflix, YouTube 등).

*   **높은 대역폭 요구:** 비디오는 데이터 양이 매우 크다.
*   **이질적인 사용자 (Heterogeneity):** 사용자의 접속 속도(대역폭)와 기기 성능이 천차만별이다. 누구는 광랜, 누구는 느린 3G를 쓴다.
*   **압축 (Compression):** 원본 비디오는 너무 크므로 압축이 필수다.
    *   **공간적 중복 제거:** 이미지 내의 반복되는 색상/패턴 압축.
    *   **시간적 중복 제거:** 이전 프레임과 다음 프레임의 차이만 저장.
    *   **CBR (고정 비트율) vs VBR (가변 비트율):** 네트워크 상황에 따라 화질을 조절하기 위해 비트율 개념이 중요함.

## DASH (Dynamic Adaptive Streaming over HTTP)
과거의 단순 다운로드나 UDP 스트리밍 방식의 한계를 극복하고, 현재 표준으로 자리 잡은 방식이다. 핵심은 "지능은 클라이언트에 있다"는 것이다.

### A. 서버의 역할
*   비디오를 여러 개의 작은 **조각(Chunk)** 단위로 나눈다 (예: 4초 단위).
*   각 조각을 여러 가지 화질(비트율)로 인코딩하여 저장한다 (저화질, 중화질, 고화질 등).
*   **매니페스트 파일(Manifest File, MPD):** 각 조각의 URL과 비트율 정보를 담은 파일을 제공한다.

### B. 클라이언트의 역할 (지능적 선택)
1.  매니페스트 파일을 먼저 받아온다.
2.  현재 자신의 **가용 대역폭(네트워크 속도)**을 실시간으로 측정한다.
3.  매번 조각을 요청할 때마다, **현재 속도에서 버퍼링 없이 재생 가능한 최대 화질**의 조각을 선택해서 요청한다.
    *   *속도가 빠르면:* 고화질 청크 요청.
    *   *속도가 느려지면:* 저화질 청크 요청.

> **DASH의 장점:** 네트워크 상황이 변해도 끊김(Re-buffering)을 최소화하고 최적의 화질을 유지할 수 있다.

## CDN (Content Distribution Network)
전 세계 수억 명의 사용자에게 단일 데이터 센터에서 비디오를 보내는 것은 불가능하다. 이를 해결하기 위해 전 세계에 분산된 서버 네트워크인 CDN을 사용한다.

### A. CDN 서버 배치 철학
1.  **Enter Deep:**
    *   전 세계 수많은 접속 ISP(통신사) 네트워크 **내부 깊숙이** 서버를 설치한다. (Akamai 방식)
    *   *장점:* 사용자와 매우 가까워 지연 시간이 짧고 처리율이 좋다.
    *   *단점:* 수천 개의 지점을 관리해야 하므로 유지보수가 어렵다.
2.  **Bring Home:**
    *   ISP 근처의 핵심 **IXP(인터넷 교환 지점)** 몇 곳에 거대한 서버 클러스터를 구축한다. (Google, Limelight 방식)
    *   *장점:* 관리 지점이 적어 유지보수가 쉽다.
    *   *단점:* 사용자에게서 상대적으로 멀어 지연 시간이 약간 더 길 수 있다.

## CDN 동작 원리 (DNS 리다이렉션)
사용자가 넷플릭스 영상을 클릭했을 때, 어떻게 가장 가까운 CDN 서버로 연결될까? 여기서 **DNS**가 핵심 역할을 한다.

1.  사용자가 `video.netcinema.com`에 접속 시도.
2.  로컬 DNS가 넷플릭스(NetCinema) DNS 서버에 IP를 물어봄.
3.  넷플릭스 DNS는 IP를 주는 대신, CDN 업체(KingCDN)의 호스트 이름으로 **CNAME(별칭) 리다이렉트**를 해줌.
4.  로컬 DNS는 다시 KingCDN의 DNS 서버에 IP를 물어봄.
5.  KingCDN의 DNS는 사용자의 IP(위치)를 보고 **가장 적절한(가까운) CDN 서버의 IP**를 알려줌.
6.  사용자는 해당 CDN 서버에서 미디어 조각을 받아옴 (DASH).

## 클러스터 선택 전략 (Cluster Selection Strategies)
CDN의 DNS는 어떤 서버가 '최적'인지 어떻게 판단할까?

*   **지리적 거리:** IP 데이터베이스를 이용해 지리적으로 가장 가까운 서버를 할당. (하지만 지리적으로 가까워도 네트워크 경로는 혼잡할 수 있음)
*   **실시간 측정:** 각 클러스터가 주기적으로 프로브(Probe) 패킷을 보내 네트워크 지연과 혼잡도를 실시간으로 측정하여 할당.

### 💡 오늘의 회고 (Reflection)
*   **DASH의 철학:** 서버가 모든 걸 통제하는 것이 아니라, 클라이언트가 스스로 상황을 판단하고 결정하게 만든 구조가 인상적이다. 인터넷의 "End-to-End 원칙"과도 맞닿아 있는 느낌이다. 유튜브 화질이 `자동`으로 설정되어 있을 때, 네트워크가 느려지면 화질이 깍두기처럼 변했다가 다시 좋아지는 게 바로 이 DASH 때문이었다.
*   **DNS의 재발견:** 2.4장에서 배운 DNS가 단순히 이름을 주소로 바꾸는 전화번호부인 줄 알았는데, CDN에서는 트래픽을 전 세계로 분산시키는 역할을 한다는 점이 놀랍다.
*   **스트리밍의 물리적 실체:** 우리가 보는 넷플릭스 영화가 미국 본사 서버에서 오는 게 아니라, 사실은 우리 집 근처(아마도 통신사 국사 내부)에 있는 '캐시 서버'에서 온다는 사실을 알게 되었다. 인터넷은 논리적 연결이지만, 속도를 위해선 결국 물리적 거리를 좁혀야 한다.

---

# 전송 계층 서비스 및 개요

## 전송 계층과 네트워크 계층의 관계
전송 계층(Transport Layer)은 애플리케이션 계층 바로 아래에 위치하며, 네트워크 계층(IP) 바로 위에 있다. 이 두 계층의 차이를 이해하는 것이 핵심이다.

*   **네트워크 계층 (Network Layer):**
    *   호스트(Host)들 사이의 논리적 통신을 제공한다.
    *   데이터를 목적지 컴퓨터(IP 주소)까지 배달하는 역할.
*   **전송 계층 (Transport Layer):**
    *   프로세스(Process)들 사이의 논리적 통신을 제공한다.
    *   네트워크 계층이 배달해 준 데이터를 컴퓨터 내부의 어떤 프로그램(Port)이 받아야 하는지 구분해준다.
*   **위치:** 전송 계층 프로토콜은 오직 종단 시스템(End System)에서만 구현된다. (네트워크 라우터는 전송 계층 정보를 처리하지 않고, 네트워크 계층 필드까지만 확인한다.)


## 비유: 아이들과 우편 서비스 (The Analogy)
책에서는 이 두 계층의 관계를 '집'과 '아이들'에 비유한다.

*   **상황:** 
    *   집 A에는 앨리스를 포함한 12명의 아이가 살고, 집 B에는 밥을 포함한 12명의 아이가 산다.
    *   집 A의 맏형 '앤(Ann)'과 집 B의 맏형 '빌(Bill)'은 동생들의 편지를 걷어서 우체통에 넣고, 온 편지를 동생들에게 나눠준다.
*   **매핑:**
    *   **호스트(Host):** 집 (House)
    *   **프로세스(Process):** 아이들 (Kids)
    *   **애플리케이션 메시지:** 편지 봉투 안의 편지 내용
    *   **네트워크 계층 프로토콜:** 우편 서비스 (Postal Service) - 집에서 집으로 이동
    *   **전송 계층 프로토콜:** 앤과 빌 (Ann & Bill) - 집 안에서 편지를 수거/분배

> **핵심 시사점:** 앤과 빌(전송 계층)은 우편 서비스(네트워크 계층)에 의존한다. 우편 서비스가 늦게 배달하면(지연), 앤과 빌이 빨리 배달할 방법은 없다. 하지만 우편 서비스가 편지를 잃어버리거나 내용을 망가뜨릴 때, 앤과 빌이 복사본을 보내거나 확인하는 방식(신뢰성)을 추가할 수는 있다.


## 인터넷의 전송 계층 (TCP & UDP)
인터넷의 네트워크 계층 프로토콜은 IP(Internet Protocol)다. IP는 최선형 서비스(Best-effort delivery service)를 제공한다. 즉, 노력은 하지만 비신뢰적(Unreliable)이다 (순서 보장 X, 도착 보장 X).

전송 계층은 이 IP 위에 얹혀져서 애플리케이션에 두 가지 다른 서비스를 제공한다.

### A. UDP (User Datagram Protocol)
*   IP 서비스에 **두 가지 최소 기능**만 추가한 것이다.
    1.  **다중화/역다중화 (Multiplexing/Demultiplexing):** 프로세스 구분 (포트 번호).
    2.  **오류 검출 (Error Checking):** 데이터가 깨졌는지 확인.
*   IP와 마찬가지로 **비신뢰적** 서비스다.

### B. TCP (Transmission Control Protocol)
*   UDP의 기본 기능(프로세스 구분, 오류 검출)에 더해 IP가 제공하지 않는 **신뢰성**을 제공한다.
    *   **신뢰적 데이터 전송 (Reliable Data Transfer):** 흐름 제어, 순서 번호, 확인 응답, 타이머 등을 사용해 데이터가 손실 없이 순서대로 도착함을 보장한다.
    *   **혼잡 제어 (Congestion Control):** 네트워크가 붐비면 전송 속도를 조절하여 네트워크 전체(IP)가 마비되는 것을 막는다.


## 논리적 통신 (Logical Communication)
*   애플리케이션 입장에서 보면, 전송 계층 덕분에 마치 **프로세스와 프로세스가 직접 연결된 파이프**를 통해 통신하는 것처럼 느껴진다.
*   실제로는 수많은 라우터와 링크를 거치지만, 전송 계층이 이 복잡한 물리적/네트워크적 세부 사항을 숨겨준다(추상화).

### 💡 오늘의 회고 (Reflection)
*   **라우터는 전송 계층을 모른다:** 데이터가 전송될 때 중간에 있는 라우터들은 IP 주소만 볼 뿐, 그 안에 담긴 TCP/UDP 헤더나 포트 번호는 신경 쓰지 않는다는 점(원칙적으로)이 계층화의 핵심인 것 같다.
*   **제약 조건 내에서의 향상:** 전송 계층은 기반이 되는 네트워크 계층(IP)의 성능(대역폭, 지연시간)을 근본적으로 뛰어넘을 수는 없다. 하지만 '신뢰성' 같은 기능은 소프트웨어적으로 구현하여 IP의 단점을 보완할 수 있다는 점이 인상적이다. "우편 서비스가 편지를 잃어버려도, 앤과 빌이 복사본을 가지고 있다가 다시 보내주면 된다"는 비유가 딱 들어맞는다.
*   **다중화의 필수성:** TCP든 UDP든 공통적으로 수행하는 가장 기본적인 임무는 결국 "이 데이터가 내 컴퓨터의 **어떤 프로그램(크롬? 카톡?)** 껍니까?"를 구분해주는 것(역다중화)이다. 이것이 전송 계층 존재의 가장 기초적인 이유임을 알았다.

---

# 다중화와 역다중화

## 다중화와 역다중화의 개념
전송 계층(Transport Layer)이 호스트 대 호스트 전달 서비스(IP)를 프로세스 대 프로세스 전달 서비스로 확장하는 가장 기본적인 방법이다.

*   **역다중화 (Demultiplexing):**
    *   수신 측(Receiver)에서의 작업.
    *   전송 계층 세그먼트의 헤더 정보(포트 번호)를 검사하여, 올바른 소켓(애플리케이션 프로세스)으로 데이터를 전달하는 것.
    *   *비유:* 우편 배달부(앤/빌)가 집에 도착한 편지를 보고, 수신자 이름(밥, 앨리스 등)을 확인하여 각자의 방(소켓)으로 가져다주는 것.
*   **다중화 (Multiplexing):**
    *   송신 측(Sender)에서의 작업.
    *   여러 소켓에서 데이터를 모으고(Gathering), 각 데이터에 헤더 정보(포트 번호 등)를 붙여서 캡슐화한 뒤, 네트워크 계층으로 내려보내는 것.
    *   *비유:* 앤/빌이 형제들의 편지를 수거하여 우체통에 넣는 것.

## 소켓 식별을 위한 정보 (포트 번호)
다중화/역다중화를 위해 전송 계층 세그먼트에는 특별한 필드가 필요하다.

*   **포트 번호 (Port Number):** 0 ~ 65535 범위의 16비트 정수.
    *   **Well-known Ports (0 ~ 1023):** HTTP(80), FTP(21) 등 널리 사용되는 프로토콜을 위해 예약됨.
*   **소켓 주소:** 모든 세그먼트는 출발지 포트 번호(Source Port)와 목적지 포트 번호(Destination Port) 필드를 포함한다.

## 비연결형 다중화/역다중화 (UDP)
UDP 소켓은 **(목적지 IP 주소, 목적지 포트 번호)** 두 가지 정보(2-tuple)로만 식별된다.

*   **동작 방식:**
    *   서버(수신자)는 특정 포트(예: 12345)를 열어두고 기다린다.
    *   클라이언트 A(IP: A, Port: 100)와 클라이언트 B(IP: B, Port: 200)가 둘 다 서버의 12345 포트로 패킷을 보내면?
    *   **결과:** 두 패킷 모두 서버의 **동일한 UDP 소켓**으로 들어간다.
*   **응답:** 서버 프로세스는 수신된 패킷에서 출발지 IP와 포트를 추출하여, 그 주소로 답장을 보낸다.

## 연결 지향형 다중화/역다중화 (TCP)
TCP 소켓은 **(출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트)** 네 가지 정보(4-tuple)로 식별된다. **이 점이 UDP와 결정적으로 다르다.**

*   **동작 방식:**
    *   TCP 서버는 "환영 소켓(Welcoming Socket)"을 포트 80번에 열어둔다.
    *   클라이언트 A와 클라이언트 B가 각각 서버의 80번 포트로 연결을 시도한다.
    *   서버는 핸드셰이킹 후, A를 위한 전용 소켓과 B를 위한 전용 소켓을 **따로** 만든다.
    *   **결과:** 목적지 IP와 포트(80)가 같더라도, **출발지 IP나 출발지 포트가 다르면 서로 다른 소켓으로 역다중화(분배)**된다.
*   **의의:** 이를 통해 서버는 동시에 수천 명의 사용자와 1:1로 구분된 통신을 할 수 있다.


## 웹 서버와 멀티스레딩
실제 고성능 웹 서버(Apache, Nginx 등)의 동작 방식이다.

*   하나의 프로세스가 모든 소켓을 관리하는 대신, 보통 새로운 연결이 생길 때마다 새로운 스레드(Thread)를 생성한다.
*   각 스레드는 고유의 4-tuple(출발지/목적지 IP/Port)을 가진 TCP 연결 소켓 하나를 전담하여 처리한다.
*   (최근에는 스레드 오버헤드를 줄이기 위해 하나의 프로세스가 여러 소켓을 관리하는 이벤트 기반 방식을 쓰기도 하지만, 논리적인 소켓 구분 원리는 같다.)


### 💡 오늘의 회고 (Reflection)
*   **UDP와 TCP의 소켓 식별 차이:** 오늘 배운 가장 중요한 포인트다.
    *   UDP는 "목적지"만 같으면 같은 구멍(소켓)으로 다 들어와서 섞인다. (2-tuple)
    *   TCP는 "누가 보냈는지"까지 따져서 서로 다른 구멍(소켓)으로 안내한다. (4-tuple)
    *   이 차이 때문에 UDP는 코딩이 단순하고, TCP는 연결 관리가 복잡하다는 것을 재확인했다.
*   **포트 80의 비밀:** "수만 명이 네이버(포트 80)에 접속하는데 어떻게 안 섞이지?"라는 의문이 풀렸다. 서버의 80번 포트는 '대문'일 뿐이고, 입장하고 나면 각자 다른 '테이블(연결 소켓)'로 안내받기 때문에 혼선이 없는 것이다.
*   **보안 관점:** 열려 있는 포트는 공격의 대상이 될 수 있다. 역다중화 원리를 악용해 특정 포트에 이상한 패킷을 보내는 것이 포트 스캐닝이나 DoS 공격의 기초가 될 수 있겠다는 생각이 든다.

---

# 비연결형 전송: UDP

## 1. UDP (User Datagram Protocol) 개요
UDP는 트랜스포트 계층 프로토콜이 할 수 있는 **최소한의 기능**만을 수행하는 '깡통' 프로토콜이다.
*   **RFC 768:** 아주 짧고 단순한 문서로 정의되어 있다.
*   **최선형 서비스 (Best-Effort Service):** IP와 마찬가지로 데이터를 목적지까지 보내려고 노력은 하지만, 보장은 하지 않는다.
    *   데이터가 손실될 수 있다.
    *   데이터가 순서가 뒤바뀌어 도착할 수 있다.
*   **비연결형 (Connectionless):** 송신자와 수신자 사이에 핸드셰이킹(연결 설정) 과정이 없다.

## 왜 TCP 대신 UDP를 쓰는가? (장점)
많은 애플리케이션(특히 멀티미디어, DNS 등)이 TCP의 신뢰성보다는 UDP의 **속도와 단순함**을 선호한다.

1.  **정교한 제어 (Finer application-level control):**
    *   TCP는 혼잡 제어(Congestion Control) 때문에 네트워크가 막히면 전송 속도를 강제로 늦춘다.
    *   UDP는 그런 거 없다. 애플리케이션이 보내고 싶은 속도대로 데이터를 쏟아부을 수 있다. (실시간 통화 등에서 약간의 끊김이 있더라도 지연되는 것보다 낫기 때문)
2.  **연결 설정 지연 없음 (No connection establishment):**
    *   TCP는 데이터 전송 전 3-way handshake로 인해 최소 1 RTT(왕복 시간)가 소모된다.
    *   UDP는 준비 없이 바로 쏜다. (DNS가 UDP를 쓰는 주된 이유: "IP 뭐야?" -> "이거야" 끝.)
3.  **연결 상태 유지 안 함 (No connection state):**
    *   TCP 서버는 각 연결마다 버퍼, 파라미터 등 상태 정보를 메모리에 유지해야 한다.
    *   UDP는 상태가 없으므로 서버 하나가 훨씬 많은 클라이언트를 감당할 수 있다.
4.  **작은 패킷 헤더 오버헤드 (Small packet header overhead):**
    *   **TCP 헤더:** 20 바이트.
    *   **UDP 헤더:** **8 바이트**. (네트워크 대역폭을 덜 잡아먹는다.)

## UDP 세그먼트 구조
매우 단순하다. 딱 4개의 필드(각 2바이트)로 구성된 **8바이트 헤더**를 가진다.

| 필드 | 설명 |
| :--- | :--- |
| **출발지 포트 번호** | (Source Port) 응답을 받을 주소 |
| **목적지 포트 번호** | (Dest Port) 데이터를 받을 프로세스 주소 |
| **길이 (Length)** | 헤더를 포함한 UDP 세그먼트 전체의 길이 (바이트 단위) |
| **체크섬 (Checksum)** | 데이터 오류 검출용 필드 |
| **애플리케이션 데이터** | 실제 전송할 메시지 내용 |

## UDP 체크섬 (Checksum)
UDP는 신뢰성이 없지만, 최소한 "데이터가 깨졌는지(Error detection)"는 확인해준다.

*   **동작 원리:**
    1.  세그먼트 내의 모든 16비트 단위 단어들을 더한다.
    2.  더하는 중에 발생하는 오버플로는 다시 더한다 (Wrap around).
    3.  최종 결과의 1의 보수(1's complement)를 취해 체크섬 필드에 넣는다.
    4.  수신 측은 받은 데이터와 체크섬을 다 더해서 결과가 `11111111...`이 나오는지 확인한다. (아니면 오류 발생)
*   **오류 처리:** 오류가 검출되면 UDP는 해당 패킷을 그냥 **버리거나**, 경고와 함께 애플리케이션에 넘겨준다. (복구/재전송 기능은 없다.)
*   **필요한 이유 (End-to-End Principle):** 링크 계층(이더넷 등)이 오류 검사를 해주긴 하지만, 라우터 메모리 내부에서 비트가 뒤집히는 등의 오류는 못 잡는다. 종단 간(End-to-End)의 무결성을 위해 전송 계층에서도 최소한의 검사가 필요하다.

## UDP 위에서의 신뢰적 전송
UDP를 쓴다고 해서 반드시 신뢰성을 포기해야 하는 것은 아니다.
*   **방법:** 애플리케이션 계층에서 직접 신뢰성을 구현하면 된다.
*   **예시 (QUIC / HTTP/3):** 구글의 크롬 브라우저와 유튜브 등은 **QUIC** 프로토콜을 사용한다. 이는 UDP 위에 독자적인 신뢰성, 혼잡 제어 기능을 얹은 것이다. TCP의 무거움은 버리고 필요한 신뢰성만 챙긴 케이스다.

### 💡 오늘의 회고 (Reflection)
*   **단순함의 미학:** TCP가 "모든 상황을 대비한 무거운 정장"이라면, UDP는 "빠르게 달리기 위한 런닝셔츠" 같다. 기능이 적은 것이 단점이 아니라, 특정 목적(속도, 효율)을 위한 강력한 장점이 된다.
*   **DNS의 선택:** 웹 서핑을 할 때마다 수없이 일어나는 DNS 조회가 만약 TCP였다면 인터넷이 훨씬 느리게 느껴졌을 것이다. 핸드셰이킹 없는 1 RTT 통신이 사용자 경험에 큰 영향을 준다는 것을 깨달았다.
*   **체크섬의 한계:** 체크섬은 "오류가 있다/없다"만 알려줄 뿐, "어디가 틀렸으니 고치자"는 못한다는 점을 기억해야 한다. 고치는 건 TCP(재전송)의 몫이거나, 쿨하게 버리는 UDP의 몫이다.
*   **HTTP/3의 역설:** "신뢰성이 필요해서 TCP를 쓴다"는 통념이 깨졌다. 현대의 웹(HTTP/3)은 오히려 UDP 기반 위에 신뢰성을 직접 코딩해서 올리는 추세다. OS 커널의 TCP 스택을 건드리기 어려우니, 앱 레벨(UDP 위)에서 최적화하려는 시도가 인상적이다.
---

**컴퓨터 네트워킹: 하향식 접근 (8판)**의 **3.4장 신뢰적 데이터 전송의 원리(Principles of Reliable Data Transfer)** 내용을 바탕으로 작성한 TIL 정리입니다.

이 장은 전송 계층의 하이라이트이자 가장 이론적인 부분입니다. 신뢰성 없는 채널(IP) 위에서 어떻게 완벽하게 신뢰할 수 있는 프로토콜을 만드는지 단계별로 진화시키며 설명합니다.

---

# 신뢰적 데이터 전송의 원리

## 1. 문제 상황 정의
*   **목표:** 데이터 손실, 손상, 순서 뒤바뀜이 없는 **신뢰적 데이터 전송(RDT, Reliable Data Transfer)** 프로토콜을 만드는 것.
*   **현실:** 하위 계층(네트워크 계층)은 **비신뢰적**이다. 비트가 깨질 수도 있고(Bit error), 패킷이 아예 사라질 수도 있다(Packet loss).
*   **접근법:** 완벽한 채널(rdt 1.0)부터 시작해서, 현실의 문제점(오류, 손실)을 하나씩 추가하며 프로토콜을 발전시킨다. (유한 상태 머신, FSM으로 표현)

## RDT의 진화 과정

### A. rdt 1.0: 완벽한 채널상의 신뢰적 전송
*   **가정:** 하위 채널이 완벽하다. 비트 오류도 없고 패킷 손실도 없다.
*   **동작:** 송신자는 그냥 보내고, 수신자는 그냥 받는다. 제어 로직이 필요 없다.

### B. rdt 2.0: 비트 오류가 있는 채널 (ACK/NAK)
*   **가정:** 패킷 전송 중 비트가 뒤집힐 수 있다(Bit error). 하지만 패킷이 사라지지는 않는다.
*   **해결책 (ARQ 프로토콜):**
    1.  **오류 검출:** 체크섬(Checksum) 사용.
    2.  **수신자 피드백:**
        *   **ACK (Positive Acknowledgement):** "잘 받았어."
        *   **NAK (Negative Acknowledgement):** "깨졌어. 다시 보내."
    3.  **재전송:** NAK를 받으면 송신자는 패킷을 다시 보낸다.
*   **치명적 결함:** **ACK나 NAK 패킷 자체도 깨질 수 있다.** 송신자는 수신자가 뭘 말했는지 모른다. 무작정 다시 보내면 수신자는 이게 '새 패킷'인지 '중복 패킷'인지 모른다.

### C. rdt 2.1: 순서 번호 (Sequence Number)
*   **해결책:** 패킷 헤더에 순서 번호(0, 1)를 붙인다.
*   **동작:**
    *   수신자는 패킷 번호를 보고 "아, 아까 받은 0번이 또 왔네(중복)?" 하고 데이터를 버리고 ACK만 다시 보낸다.
    *   Stop-and-Wait 방식이므로 0과 1, 단 1비트만 있으면 된다.

### D. rdt 2.2: NAK 없애기
*   NAK를 별도로 만드는 대신, "가장 마지막으로 정확하게 수신된 패킷에 대한 ACK"를 보낸다.
*   *예:* 1번을 기다리는데 0번 ACK가 오면? -> "아, 송신자가 내 1번 ACK를 못 받았거나, 내가 보낸 게 깨졌구나"라고 판단하고 재전송. (TCP는 이 방식을 쓴다)

### E. rdt 3.0: 손실이 있는 채널 (타이머)
*   **문제:** 패킷이 전송 중에 아예 사라지면(Loss), 송신자는 ACK를 하염없이 기다리는 **데드락**에 빠진다.
*   **해결책:** **카운트다운 타이머 (Countdown Timer)**.
*   **동작:** 송신자는 패킷을 보내고 타이머를 켠다. 시간 내에 ACK가 안 오면 **무조건 손실로 간주하고 재전송**한다.
*   *주의:* 패킷이 안 사라지고 단순히 늦게 도착한 경우(지연)에도 중복 전송이 발생하지만, rdt 2.1의 순서 번호 덕분에 수신자가 중복을 걸러낼 수 있다.

## 파이프라이닝 (Pipelining) - 성능 개선
rdt 3.0은 기능적으로 완벽하지만*성능(Performance)이 끔찍하다. **Stop-and-Wait(보내고 기다리기)** 방식이기 때문이다.
*   **해결책:** ACK를 기다리지 않고 여러 패킷을 한꺼번에 쏟아붓는다. 이것을 파이프라이닝이라고 한다.
*   **필요조건:**
    1.  순서 번호의 범위가 커야 한다 (0, 1로는 부족).
    2.  송신자와 수신자 양쪽에 버퍼(메모리)가 있어야 한다.

## 파이프라이닝 프로토콜: GBN vs SR
파이프라이닝 오류 회복 방식에는 크게 두 가지가 있다.

### A. GBN (Go-Back-N, N으로 돌아가기)
*   **송신자:** 윈도우 크기 $N$만큼 ACK 없이 보낼 수 있다.
*   **누적 확인응답 (Cumulative ACK):** `ACK n`은 "$n$번 패킷까지 **모두** 완벽하게 받았다"는 뜻.
*   **타이머:** **가장 오래된 전송된 패킷**에 대해 하나의 타이머만 사용.
*   **오류 발생 시:** 타임아웃이 나면, 확인응답 안 된 **모든 패킷을 재전송**한다 (Go Back to N).
*   **수신자:** 순서가 안 맞는 패킷이 오면? **그냥 버린다.** (버퍼링 안 함, 구현 단순).

### B. SR (Selective Repeat, 선택적 반복)
*   **송신자:** 각 패킷마다 **개별 타이머**를 가진다.
*   **개별 확인응답:** `ACK n`은 "$n$번 패킷 하나만 잘 받았다"는 뜻.
*   **오류 발생 시:** 타임아웃이 난 **그 패킷 하나만** 다시 보낸다.
*   **수신자:** 순서가 안 맞는 패킷이 오면? **버퍼에 저장**해두고, 빠진 게 채워지면 한꺼번에 상위 계층으로 올린다.

## 요약: 신뢰적 데이터 전송의 메커니즘
| 메커니즘 | 용도 및 설명 |
| :--- | :--- |
| **체크섬** | 비트 오류 검출. |
| **타이머** | 패킷 손실 감지 (재전송 트리거). |
| **순서 번호** | 데이터 패킷의 중복 방지 및 순서 맞추기. |
| **ACK (확인응답)** | 수신자가 송신자에게 "잘 받았다"고 알림. |
| **NAK (부정응답)** | "잘못 받았다"고 알림 (보통은 ACK + 순서 번호로 대체). |
| **윈도우, 파이프라이닝** | 처리율(Throughput) 향상을 위해 한 번에 여러 개 전송. |

### 💡 오늘의 회고 (Reflection)
*   **Stop-and-Wait의 비효율성:** 빛의 속도로 왕복하는 시간(RTT) 동안 아무것도 안 하고 멍하니 기다리는 것이 얼마나 자원 낭비인지 수식(이용률, $U_{sender}$)을 통해 확인했다. 파이프라이닝은 선택이 아니라 필수다.
*   **GBN vs SR의 트레이드오프:**
    *   **GBN:** 구현이 쉽다(수신자 버퍼 불필요). 하지만 하나만 잃어버려도 멀쩡한 뒤 패킷까지 우르르 다시 보내야 하니 네트워크 낭비가 심할 수 있다.
    *   **SR:** 효율적이다(잃어버린 것만 재전송). 하지만 구현이 복잡하고 송수신자 양쪽에 버퍼가 필요하다.
    *   *현실의 TCP:* TCP는 GBN과 SR의 혼합 형태(누적 ACK를 쓰지만, 수신자가 버퍼링을 함)를 쓴다는 점이 흥미롭다.
*   **신뢰성의 대가:** 공짜는 없다. 신뢰성을 얻기 위해 체크섬 계산(CPU), 타이머 관리(OS 리소스), 순서 번호(헤더 오버헤드), ACK 패킷(대역폭), 재전송(지연) 등 엄청난 비용을 지불해야 한다.