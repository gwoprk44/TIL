# 목차

## 네트워크 애플리케이션의 원리

### 앱은 어떻게 통신하는가? - 두가지 구조(클라이언트-서버 vs p2p)
네트워크 앱의 구조는 크게 두 가지로 구분할 수 있다.
- 클라이언트-서버 모델: 항상 켜져서 요청을 기다리는 **서버(Server)**와 필요할 때 서비스를 요청하는 **클라이언트(Client)**로 구성된다. 마치 식당(서버)과 손님(클라이언트)의 관계와 같다. 우리가 사용하는 대부분의 웹 서비스가 이 구조다.
-  P2P (Peer-to-Peer) 모델: 중앙 서버 없이 모든 컴퓨터(피어, Peer)가 동등한 입장에서 서로 직접 통신한다. 모든 피어가 서버이자 클라이언트가 될 수 있다. 토렌트(BitTorrent)가 대표적인 예시다.

### 프로그램끼리는 어떻게 서로를 찾는가? - 주소와 문(Port)
서로 다른 컴퓨터에서 실행되는 프로그램(프로세스)끼리 통신을 하려면 서로를 찾아갈 주소가 필요하다.
- IP 주소: 네트워크에 연결된 컴퓨터(호스트)의 주소
- 포트 번호: 해당 컴퓨터 안에서 실행되고 있는 수많은 프로그램 중 특정 프로그램을 식별하는 번호.
- 통신을 위해서는 `IP주소 + 포트번호` 모두가 필요하다.

### 어떤 방식으로 데이터를 보낼것인가? - TCP vs UDP
애플리케이션의 특성에 따라 데이터를 보내는 방식(전송 프로토콜)을 결정해야 한다.

#### TCP
- 특징: 신뢰성과 순서 보장
- 동작:
  - 상대방과의 연결을 확인(3-way handshake)
  - 데이터를 순서대로 전송하며, 잘 받았는지 확인
  - 데이터가 중간에 유실되면 재전송.
- 장점: 데이터가 정확히 전송됨을 보장.
- 단점: 확인 절차 때문에 UDP보다 느림.
- 사용 예: 웹 브라우징, 파일 전송, 이메일 등 데이터의 정확성이 요구되는 부분.

#### UDP
- 특징: 빠른 속도.
- 동작.
  - 연결 확인절차 없이 데이터를 전송.
  - 데이터가 중간에 유실되거나 순서가 바뀌어도 신경쓰지않는다.
- 장점: 매우 빠르고 효율적.
- 단점: 데이터 전송을 보장하지 않는다(비신뢰).
- 사용 예: 온라인 게임, 실시간 영상 스트리밍 등.

우리가 사용하는 인터넷 앱은 클라이언트-서버 또는 P2P 구조를 가지며, IP와 포트를 이용해 통신 대상을 찾는다. 그리고 앱의 성격에 따라 신뢰성이 중요한 TCP를 쓸지, 속도가 중요한 UDP를 쓸지 결정하는 것이다. 이 간단한 원리가 복잡한 네트워크의 시작점이다.

---

## 웹과 HTTP

### 웹 통신은 기본적으로 '단기 기억 상실증'
HTTP는 기본적으로 비상태(Statelss)를 유지한다. 서버는 방금 요청한 클라이언트가 누구인지 기억하지 않는다. 매번 당신은 누구십니까? 하고 묻는것과 같다.
- 장점: 서버가 클라이언트 정보를 저장할 필요가없어 구조가 단순하고 확장이 용이하다.
- 단점: 로그인을 유지하거나 장바구니에 물건을 담는 것처럼 상태 유지가 필요할땐 문제가 된다.

### 서버는 날 어떻게 알아보는가? - 쿠키(Cookies) 사용
서버가 나(클라이언트)를 기억하게 하는 방법이 바로 쿠키이다.
1. 서버: 클라이언트가 처음 접속했을 때, 나를 식별할 수 있는 작은 표식을 응답 메시지에 담아 보낸다(Set-Cookie 헤더)
2. 클라이언트 브라우저: 그 표식(쿠키)를 보관한다.
3. 클라이언트: 이후 그 서버에 요청할 때마다 보관해둔 표식을 항상 같이 보낸다.(Cookie 헤더)
결국, 서버는 이 표식을 보고 클라이언트를 알아본다.

### 통신에도 효율이 존재 - 비지속 연결 vs 지속 연결
웹 페이지 하나에는 HTML 파일, 여러 개의 이미지 파일, CSS 파일 등 수많은 '객체'가 있다. 이것들을 어떻게 가져오느냐에 따라 속도가 달라진다.
- 비지속 연결 (옛날 방식, HTTP/1.0): 객체 하나 가져올 때마다 TCP 연결을 새로 맺고 끊는다. 이미지 10개면 연결도 10번! 매우 비효율적이다.
- 지속 연결 (요즘 방식, HTTP/1.1): TCP 연결을 한번 맺으면, 그 연결을 통해 여러 객체를 한꺼번에 요청하고 받는다. 전화 한 번 걸어서 모든 용건을 말하는 것과 같아서 훨씬 빠르다.

### 웹 통신의 언어 - HTTP 메시지
브라우저(클라이언트)와 서버는 정해진 양식의 메시지를 주고받는다.
- 요청 메시지 (클라이언트 → 서버): "저기요, 이 페이지 좀 주세요!"
  - GET /index.html HTTP/1.1: GET(가져와줘), /index.html(이 파일을), HTTP/1.1(이 버전으로)
  - 헤더: Host(어느 서버인지), User-Agent(내 브라우저 정보) 등 부가 정보
- 응답 메시지 (서버 → 클라이언트): "네, 여기 있습니다!" 또는 "없는데요?"
  - HTTP/1.1 200 OK: HTTP/1.1(이 버전으로), 200 OK(성공적으로 처리했어!)
  - 헤더: Content-Type(이 파일은 HTML이야), Content-Length(파일 크기) 등 부가 정보
  - 본문(Body): 실제 HTML 파일 데이터

💡주요 상태 코드
- 200 OK: 성공!
- 301 Moved Permanently: 이사 갔으니 저쪽 주소로 다시 요청해.
- 404 Not Found: 요청한 파일 여기 없어. (우리가 흔히 보는 그 페이지!)
- 500 Internal Server Error: 미안, 내 서버에 문제가 생겼어.

### 더 빠르게 만드는 기술 - 웹 캐시(Web Cache)
자주 가는 동네 도서관이 존재한다면, 멀리 있는 중앙 도서관까지 갈 필요가 없는 것처럼. 웹 캐시가 동네 도서관 역할을 한다.
- 클라이언트가 이미지 하나를 요청하면, 웹 캐시 서버가 원본 서버로부터 이미지를 받아 나에게 주면서 자신도 한 부 복사해둔다.
- 다음에 클라이언트가 같은 이미지를 또 요청하면, 웹 캐시는 원본 서버까지 가지 않고 자신이 저장 해둔 복사본을 바로 클라이언트에게 전달한다. -> 속도가 훨씬 빠르다.

웹 통신(HTTP)은 기본적으로 기억력이 없는 '비상태' 프로토콜이지만, '쿠키'를 통해 사용자를 식별한다. 오늘날 웹이 빠른 이유는 한 번의 연결로 여러 데이터를 주고받는 '지속 연결'과, 자주 쓰는 데이터를 가까운 곳에 저장해두는 '웹 캐시' 덕분이다.

---

## 인터넷 전자메일

### 이메일 시스템의 세 가지 핵심 요소
이메일이 동작하기 위해서는 세 가지 핵심 요소가 필요하다.
1. 사용자 에이전트(User Agent): 우리가 직접 사용하는 프로그램(아웃록, 메일 앱, 웹 메일 등) 메일을 작성하고, 읽고, 관리하는 역할.
2. 메일 서버(Mail Server): 이메일 시스템의 핵심. 24시간 동작하며 사용자를 대신하여 이메일을 주고받고 보관하는 우체국 같은 존재. 모든 사용자는 자신만의 메일함(mailbox)을 이 서버에 가지고있다.
3. SMTP (Simple Mail Transfer Protocol): 메일을 '보낼 때(Push)' 사용하는 프로토콜(규칙). 내가 작성한 메일을 내 메일 서버로 보내고, 내 메일 서버가 상대방 메일 서버로 전달할 때 사용된다.

### 이메일 전송 과정
1. 작성: 사용자 에이전트에서 메일을 작성한다.
2. 전송: 전송 버튼을 누르면 SMTP를 통해 내 메일이 내 소속 메일 서버로 보내진다.
3. 서버 간 전달: 서버는 주소를 확인하고, 상대방 메일 서버를 찾아 SMTP를 이용하여 메일을 전달한다. 이 때 TCP를 이용하여 신뢰성있는 전송을 한다.
4. 보관: 상대방 서버는 전달받은 메일을 메일함에 보관한다.

>💡 핵심 포인트: 메일을 보낼 때, 즉 '밀어넣을(Push)' 때는 처음부터 끝까지 SMTP가 사용된다. 하지만 SMTP는 7비트 ASCII 문자만 전송할 수 있어서 이미지나 영상 같은 파일은 **MIME(Multipurpose Internet Mail Extensions)**라는 표준에 따라 텍스트로 변환(인코딩)되어 전송된다.

### 메일 확인하기: 두 가지 방법 (POP3 vs IMAP)
상대방 메일함에 도착한 메일을 내가 확인(가져오기, Pull)할 때는 다른 프로토콜이 필요하다. SMTP는 보내기 전용이기 때문이다. 이때 사용하는 대표적인 두 가지 방식이 있다.

- POP3 (Post Office Protocol - version 3): '다운로드 후 삭제' 모델.
  - 동작: 메일 서버에 접속해서 모든 메일을 내 PC(사용자 에이전트)로 다운로드 한 후, 서버에서는 메일을 삭제하는 것이 기본 동작.(서버에 메시지 저장본을 저장하는 옵션도 존재한다.)
  - 특징: 한 번 다운로드하면 오프라인 상태에서도 메일 읽기가 가능하다. 여러 기기에서 메일을 확인하면 동기화가 되지않아 불편하다.
- IMAP (Internet Message Access Protocol): '원격 서버 관리' 모델.
  - 동작: 모든 메일을 서버에 그대로 두고, 내가 필요할 때마다 서버에 접속하여 확인만 하는 방식. 메일을 읽거나, 폴더를 생성하거나, 삭제하는 모든 작업이 서버에 직접 반영된다.
  - 특징: 스마트폰, PC, 태블릿 등 어떤 기기에서 접속하든 항상 동일한 메일 상태가 유지된다. 지메일, 네이버 메일 등 대다수의 웹 메일 서비스가 이방식을 사용한다.

---

## DNS: 인터넷의 디렉토리 서비스

### 왜 DNS가 필요한것인가?
사람은 이름`(google.com)`을 기억하기 쉽고. 컴퓨터는 숫자(IP)를 처리하기 쉽기 때문이다. DNS는 이 둘 사이를 변환해주는 필수적인 중개자 역할을 한다. 만약 DNS가 없다면 우리는 모든 웹 사이트의 IP주소를 외워야 했을 것이다.

### DNS는 하나의 거대한 서비스가 아니다(분산 계층 구조)
DNS 서버는 전 세계에 흩어져 있는 수많은 서버들이 계층을 이루어 협력하는 분산 시스템이다. 마치 거대한 회사의 조직도와 같다.

1. 루트 DNS 서버: 전 세계에 단 13개의 논리적 그룹만 존재하는 상위. `.`을 관리하며 `.com`, `.kr`은 저기로 가라고 알려주는 안내원 역할을 한다.
2. 최상위 도메인(TLD)서버: `.com`, `.org`, `.net`, `.kr` 등 도메인 종류별 담당자. `google.com`에 대해 물으면, `'google'`을 담당하는 서버가 어디 있는지 알려준다.
3. 책임 DNS 서버 (Authoritative DNS Server): `google.com`, `naver.com` 등 실제 개별 도메인의 '진짜' IP 주소 정보를 가지고 있는 최종 담당자. 

### 주소를 찾아가는 여정(DNS Query)
컴퓨터가 `www.google.com`의 IP의 주소를 알아내는 과정은 매우 체계적이다.
1. 첫 번째 질문 (내 PC → 로컬 DNS 서버): 내 컴퓨터는 가장 먼저 ISP(KT, SKT 등)가 지정해준 로컬 DNS 서버에게 "www.google.com 주소 알아?"라고 묻는다.
2. 질문 릴레이 시작 (로컬 DNS 서버의 여정): 로컬 DNS 서버가 모르면, 이제부터 직접 발로 뛰기 시작한다.
   - (→ 루트 서버): "혹시 www.google.com 아니?" / 루트: "난 몰라. 근데 .com 담당자한테 물어봐. 걔 주소는 이거야."
   - (→ .com TLD 서버): "혹시 www.google.com 아니?" / TLD: "난 몰라. 근데 google.com 담당자(책임 서버)한테 물어봐. 걔 주소는 이거야."
   - (→ google.com 책임 서버): "혹시 www.google.com 아니?" / 책임 서버: "어! 알아. 걔 IP 주소는 142.250.204.78 이야."
   - 답변 전달: 로컬 DNS 서버는 드디어 알아낸 IP 주소를 내 컴퓨터에게 알려준다.

### DNS가 빠른 이유 - 똑똑한 캐싱
매번 우리가 인터넷을 이용할 때 위와같은 과정을 거치면 인터넷 활동이 너무 느릴것이다. 이를 해결하기 위해 바로 DNS는 캐싱을 활용한다.
- 한 번 조회했던 주소 정보는 로컬 DNS 서버가 일정 시간 동안 기억(캐시)한다.
- 만약 내가 조금 전에 접속했던 `google.com`을 다시 요청하면, 로컬 DNS 서버는 저 복잡한 과정을 또 거치지 않고 자기가 기억해둔 IP 주소를 바로 알려준다. 덕분에 속도가 엄청나게 빨라진다.

### 전화번호부 그 이상의 기능 (DNS 레코드)
DNS는 IP 주소만 알려주는 것이 아니라, 다른 정보들도 가지고 있다.
- A 레코드: 도메인 이름 → IPv4 주소 (가장 기본)
- MX 레코드: 메일 서버 주소. `user@example.com`으로 메일을 보낼 때, `example.com`의 메일 서버(SMTP 서버)가 어디인지를 알려준다. (2.3장에서 배운 이메일과 연결되는 부분!)
- CNAME 레코드: 별명. `www.example.com`을 `example.com`의 별명으로 지정할 수 있다.

---

## P2P 파일 분배
### 모두가 서버이자 클라이언트인 P2P
P2P는 중앙서버에 의존하는 대신, 네트워크에 참여한 모든 컴퓨터(피어)가 서로 직접 데이터를 주고받는 방식이다.
- 클라이언트-서버 모델의 한계: 사용자가 몰릴수록 서버의 부하가 커지고, 속도가 느려진다.(유명 가수의 티켓팅, 수강신청등을 생각해보면 된다.)
- P2P모델의 위력: 사용자가 많아 질수록 오히려 전체 시스템의 다운로드 속도가 빨라진다. -> 다운로드 하는 모든 사람이 동시에 다른 사람에게 업로드를 하는 '공유의 장'이 되기 때문이다. 확장성이 뛰어나다.

### 비트 토렌트
1. 토렌트 파일 (.torrent): 이것은 실제 파일이 아니다. 실제 파일에 대한 정보(이름, 크기, 조각 정보)와 트래커의 주소가 담긴 작은 '작전 지도' 또는 '메타데이터' 파일이다.
2. 트래커 (Tracker): 중개인 역할을 하는 서버. 특정 파일을 공유하는 피어들의 명단(IP 주소)을 관리하고, 새로 참여한 피어에게 "지금 이 파일을 공유하는 사람들은 여기 있어"라고 알려준다. (단, 트래커는 파일 자체를 가지고 있지는 않다.)
3. 스웜 (Swarm): 같은 토렌트 파일을 공유하는 모든 피어들의 집합을 '스웜'이라고 부른다.

### 비트 토렌트의 핵심 전략
- 전략 1: 파일을 잘게 나누기 (Chunks)
  - 거대한 파일(ex: 10GB 영화)을 **청크(Chunk)**라는 수많은 작은 조각(ex: 256KB)으로 나눈다.
  - 피어들은 이 조각 단위로 서로 교환한다. 덕분에 처음부터 순서대로 받을 필요 없이, 각자 다른 조각들을 동시에 다운로드하고, 다 모이면 하나로 합칠 수 있다.
- 전략 2: 희귀한 조각 먼저! (Rarest First)
  - 피어는 조각을 요청할 때, 자기가 접속한 다른 피어들에게 가장 희귀한 조각을 우선적으로 달라고 요청한다.
  - 이유: 만약 모두가 구하기 쉬운 조각만 먼저 받으려고 하면, 나중에는 희귀한 조각을 가진 피어가 사라져서 아무도 다운로드를 완료하지 못하는 상황이 생길 수 있다. 이 전략은 모든 조각이 스웜 전체에 고르게 퍼지도록 만들어 파일의 생명력을 길게 유지시킨다.
- 전략 3: 기브 앤 테이크 (Tit-for-Tat)
  - "어떻게 공짜로 받기만 하는 '먹튀(Free-rider)'를 막을까?"에 대한 영리한 해답이다.
  - 각 피어는 자신에게 데이터를 가장 빠른 속도로 보내주는(가장 많이 기여하는) 상위 4개의 다른 피어를 우선적으로 선택해 데이터를 보내준다(Unchoke).
  - 즉, **"나에게 많이 주는 너에게, 나도 많이 주겠다"**는 전략이다. 이는 모든 참여자가 적극적으로 업로드하도록 유도하는 강력한 인센티브가 된다.
  - 추가로, 무작위로 한 명을 더 선택(Optimistic Unchoke)해서 더 좋은 파트너를 찾으려는 시도도 계속한다.

---

## 비디오 스트리밍과 콘텐츠 분배 네트워크
### 스트리밍의 딜레마: 고화질 vs 끊김 없음
인터넷에서 비디오를 본다는 것은 엄청난 양의 데이터를 실시간으로 내려받는것과 같다. 여기서 딜레마가 발생한다.
- 사용자마다 인터넷 속도가 천차만별이다.
- 같은 사용자라도 네트워크 상태는 계속 변화한다.

### 이를 해결하는 DASH
DASH는 이 문제를 간단한 방법으로 해결한다. 즉, 하나의 영상이 아니라 여러 버전의 영상을 준비해놓고 네가 알아서 골라먹어 라는 방식을 사용한다.
1. 서버의 준비: 서버는 똑같은 영상을 다양한 화질(비트율)로 여러개 인코딩해 둔다.(4k, 1080, 720, 유튜브를 생각해보자.)
2. 파일 조각내기: 그리고 각 버전의 영상을 청크(Chunk)라는 수 초 길이의 작은 조각으로 잘게 나누어 저장한다.
3. 플레이어의 실시간 선택:
   - 내 비디오 플레이어는 먼저 영상에 대한 목록파일(Manifest File)을 받는다. 이 파일에는 어떤 화질의 청크들이 어디에 있는지에 대한 정보가 담겨있다.
   - 플레이어는 현재 내 네트워크 속도를 실시간으로 측정한다.
   - 지금 속도가 빠르다 -> 4k 짜리 다음 조각 선택
   - 속도가 느려졌다 -> 버퍼링 걸리기전에 480p짜리 다음 조각이라도 선택
   - 이러한 방식으로 플레이어 스스로 상황에 맞게 최적의 화질 조각을 계속해서 요청하고 재생한다.

결과적으로, 이러한 방식을 통해 우리는 버퍼링을 최소화하면서, 현재 네트워크가 허용하는 최상의 화질로 영상을 감상할 수 있다.

### 전세계를 커버하는 기술 - CDN(컨텐츠 분산 네트워크)
넷플릭스 서버가 미국에만 있다면, 한국에 있는 내가 미국까지 접속해서 영상을 봐야 하므로 엄청나게 느릴 것이다. 이 물리적 거리의 한계를 극복하는 기술이 바로 CDN이다.
- 원리: 원본 서버를 복제해서 전 세계 곳곳에 분산시키자!
  - CDN 업체는 전 세계 주요 위치에 수많은 캐시 서버를 설치해둔다.
  - 그리고 넷플릭스와 같은 콘텐츠 제공자의 영상 원본을 미리 이 캐시 서버들에 복사(캐싱)해 놓는다.
- 동작 방식
  1. 내가 한국에서 넷플릭스 영상을 재생하면,
  2. CDN은 내가 어디서 접속했는지 파악하고, 나에게서 가장 가깝고, 가장 쾌적한 상태의 한국 내 캐시 서버로 나를 연결해준다.
  3. 나는 미국 본 서버가 아닌, 내 근처의 서버에서 영상을 빠르고 안정적으로 스트리밍 할 수 있게 된다.

---

## 트랜스포트 계층 서비스 및 개요

### 트랜스포트 계층의 역할: 프로세스<->프로세스 메시지 전달
트랜스포트 계층의 역할은 아주 명확하다. 종단의 프로세스(애플리케이션)에서 다른 종단의 프로세스까지 데이터를 전달하는것이다.

- 네트워크 계층(IP)의 한계: 네트워크 계층은 단지 호스트에서 호스트까지만 데이터를 배달하는 '집배원'역할을 한다. 즉, 택배를 아파트 현관까지만 배달할 뿐, '몇 동 몇호의 누구'에게 전달할지는 모른다.
- 트랜스포트 계층의 역할: 트랜스포트 계층은 아파트 현관에 도착한 택배(데이터)를 보고, 송장에 적힌 정보(포트 번호)를 확인하여 정확한 집, 정확한 사람(프로세스)에게 전달해주는 '아파트 관리인'과 같다. 이를 논리적 통신이라 부른다.

### 어떻게 여러 앱이 동시에 통신하는것인가 - 멀티플렉싱과 디멀티플렉싱
하나의 컴퓨터에서 게임도 즐기고, 음악을 스트리밍하고, 웹서핑도 동시에 할 수 있는 이유는 트랜스포트 계층의 교통정리 덕분이다.
- 멀티플렉싱(Multiplexing - 보내기)
  - 모아서 포장하기: 내 컴퓨터의 여러 애플리케이션(프로세스)들이 각자 데이터를 보내려고 하면, 트랜스포트 계층은 이 데이터 조각들을 한 데 모은다.
  - 그리고 각각의 조각에 출발지 포트 번호와 목적지 포트 번호라는 꼬리표(헤더)를 붙여서 하나의 스트림처럼 네트워크 계층으로 내려보낸다.
- 디멀티플렉싱(Demultiplexing - 받기)
  - 꼬리표 보고 나눠주기: 상대방 컴퓨터의 트랜스포트 계층은 네트워크 계층으로부터 데이터 조각들을 받는다.
  - 그리고 각 조각들에 붙어있는 목적지 포트 번호 꼬리표를 확인하고, 그 번호에 맞는 정확한 애플리케이션(프로세스)의 문(소켓)으로 데이터를 배달한다.

결국, 이 두가지 기술 덕분에, 단 하나의 인터넷 회선을 통해 수 많은 애플리케이션이 데이터를 주고받아도 데이터가 뒤섞이는 일 없이 질서정연하게 통신이 가능하다.

### 두 가지 배송 옵션: UDP와 TCP
트랜스포트 계층은 애플리케이션의 필요에 따라 두 가지 매우 다른 성격의 배송 서비스를 제공한다.
- UDP: 빠르고 간편한 일반 우편
  - 트랜스포트 계층이 제공하는 최소한의 서비스. 멀티플렉싱/디멀티플렉싱과 간단한 오류 검사 기능만 추가한다.
  - 데이터가 중간에 사라지거나, 순서가 뒤바뀌어도 책임x
  - 장점: 매우 빠르고 오버헤드가 적음.
  - 언제 사용?: 속도가 중요하고 약간의 데이터 손실은 감수 가능한 서비스(DNS, 영상 스트리밍, 온라인 게임 등)
- TCP: 비싸지만 확실한 등기 우편
  - UDP의 기본 긴으에 두 가지 강력한 서비스를 더 제공한다.
  - 신뢰성 있는 데이터 전송: 데이터가 빠짐없이, 순서대로 도착하는것을 100% 보장한다. 데이터가 유실되면 재전송까지 포함.
  - 혼잡 제어: 인터넷이 막히는 것(혼잡)을 감지하면, 스스로 전송 속도를 줄여서 네트워크 전체가 마비되는 것을 막는다.
  - 언제 사용?: 데이터의 정확성이 절대적으로 중요한 서비스(웹 브라우징, 파일 전송, 이메일)

---

## 다중화와 역다중화
1. 문제상황: 집 주소만 아는 택배기사(IP의 한계)
   - 네트워크 계층의 IP 프로토콜은 딱 '컴퓨터(호스트)'까지만 데이터를 배달하는 '택배기사'와 같다. 즉, `192.168.0.5`라는 집 주소까지는 배달할 수 있지만, 그 집 안에 사는 '김크롬'에게 온 택배인지 '이카톡'에게 온 택배인지는 구분하지 못한다.
2. 해결책: 방 번호를 보고 우편물 분류하기(역다중화)
   - 역다중화(Demultiplexing)는 택배기사(IP)가 아파트 현관에 내려놓고 간 택배 더미를, 아파트 관리인(트랜스포트 계층)이 각 택배의 '방 번호(포트 번호)'를 보고 올바른 집(프로세스/소켓)의 우편함에 넣어주는 과정이다.
   - 동작 방식:
     1. 트랜스포트 계층은 IP로부터 데이터 덩어리(세그먼트)를 받는다.
     2. 세그먼트 헤더에 적힌 목적지 포트번호를 확인힌다.
     3. 해당 포트 번호를 사용하고 있는 올바른 프로세스의 문(소켓)으로 데이터의 내용물을 전달한다.
3. 보낼때: 택배에 방 번호 적어서 내놓기(다중화)
   - 다중화(Multiplexing)는 역다중화의 반대 과정이다. 우리 집의 여러 가족 구성원('김크롬', '이카톡', '박게임')이 각자 보낼 편지를 아파트 관리인(트랜스포트 계층)에게 건네는 것과 같다.
   - 동작 방식:
      1. 트랜스포트 계층은 여러 애플리케이션(소켓)으로 부터 데이터를 받는다.
      2. 각 데이터 덩어리에 출발지 포트 번호와 목적지 포트 번호가 적힌 헤더를 붙여 하나의 '세그먼트'로 포장한다.
      3. 이렇게 퐂아된 세그먼트들을 택배기사(IP)에게 전달하여 발송한다.
 4. 중요한 차이점: UDP와 TCP의 우편함 관리 방식
역다중화 방식은 UDP와 TCP간에 차이가 존재한다.  
- UDP (비연결형): "목적지 방 번호만 본다"
  - UDP 소켓(우편함)은 {목적지 IP, 목적지 포트}라는 2개의 정보로 식별된다.
  - UDP 세그먼트가 도착하면, 시스템은 헤더의 목적지 포트 번호만 보고 해당 포트와 연결된 소켓으로 데이터를 보낸다. 누가 보냈는지는 일단 중요하지 않다. (마치 주소만 맞으면 누구의 편지든 받는 공용 우편함 같다.)
- TCP (연결지향형): "누가 누구에게 보내는 편지인지 정확히 본다"
  - TCP 소켓(우편함)은 {출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트}라는 4개의 정보 묶음으로 식별된다.
  - 이는 마치 'A가 B에게' 보내는 전용 전화선과 같다. 웹 서버는 80번 포트라는 하나의 '대표 번호'를 가지고 있지만, 수많은 클라이언트와 동시에 통신할 수 있는 이유가 바로 이것이다. 각 클라이언트와의 연결마다 이 4가지 정보가 모두 다른 별개의 소켓(전화선)이 생성되기 때문이다.

---
