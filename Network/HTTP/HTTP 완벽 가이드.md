> HTTP 완벽 가이드 책을 읽고 정리한 내용입니다.

# HTTP 개관

## HTTP: 인터넷의 멀티미디어 배달부
HTTP는 단순한 텍스트 전송규약이 아닌, 전 세계 웹 서버와 클라이언트 간의 신뢰성있는 데이터 전송을 보장하는 애플리케이션 계층 프로토콜이다.

### 리소스와 MIME 타입
- 리소스: 웹에 존재하는 모든 컨텐츠(파일, 게이트웨이 프로그램, 검색 결과 등)을 총칭
- MIME 타입:
  - 원래 이메일 전송을 위해 설계되었으나 HTTP에서도 사용된다.
  - 서버는 데이터 전송시 `Content-Type` 헤더를 통해 데이터의 형식을 알려준다.

### URI (Uniform Resource Identifier)
리소스의 고유 식별자. URI는 URL과 URN으로 나뉜다.
- URL(Locator): 리소스의 위치를 지정. 가장 일반적인 형태.
  - 구조: `<스킴>://<서버주소>:<포트>/<경로>`
  - 예: `http://www.naver.com:80/index.html`
- URN(Name): 리소스의 이름을 지정. 위치가 변해도 이름은 유지.
  - 예: `urn:isbn:978-0-123-45678-9`(아직 널리 쓰이지는 않는다.)

---

## HTTP 트랜잭션
HTTP 트랜잭션은 요청(Request)와 응답(Response) 결과로 구성된다.

### 메서드: 서버에게 무엇을 시키는가
모든 서버가 모든 메서드를 지원하는것은 아님.
- GET: 리소스를 서버에서 클라이언트로 가져온다. (가장 많이 사용)
- POST: 클라이언트가 서버로 데이터를 보낸다. (입력 폼 전송 등)
- PUT: 서버에 문서를 저장하거나 덮어쓴다.
- DELETE: 서버에서 리소스를 삭제한다.
- HEAD: GET과 같지만, 본문(Body) 없이 헤더만 가져온다. (리소스 존재 여부 확인, 변경 여부 검사 시 유용)

### 상태코드: 결과가 어떠한가
세 자리 숫자로 구성되며, 함께 오는 사유 구문은 사람이 이해하기 위한 것.
- 100-199: 정보 (Information)
- 200-299: 성공 (Success) -> 200 OK
- 300-399: 리다이렉션 (Redirection) -> 302 Found (다른 위치로 가라)
- 400-499: 클라이언트 에러 (Client Error) -> 404 Not Found (네가 요청한 게 없다)
- 500-599: 서버 에러 (Server Error) -> 500 Internal Server Error (서버 내부 문제)

---

## 메시지 구조
HTTP 메시지는 인간이 읽을 수 있는 텍스트로 되어있다.

### 요청 메시지 (Request)
1. 시작줄: `<메서드> <URL> <버전>`
   - 예: `GET /index.html HTTP/1.1`
2. 헤더: 키: 값 형태의 메타 정보.(빈 줄로 헤더의 끝을 알린다.)
3. 본문: POST 요청시 보낼 데이터

### 응답 메시지 (Response)
1. 시작줄: `<버전> <상태코드> <사유구문>`
   - 예: `HTTP/1.1 200 OK`
2. 헤더: 컨텐츠 타입, 길이, 서버 정보 등.
3. 본문: 실제 데이터

---

## TCP 커넥션
HTTP는 네트워크 통신의 핵심인 데이터 전송을 TCP/IP에 맡긴다.

### 계층 구조
1. HTTP (애플리케이션 계층): 무엇을 보낼지 결정.
2. TCP (전송 계층): 데이터를 패킷 단위로 쪼개고, 순서대로, 에러 없이 도착하도록 보장.
3. IP (네트워크 계층): 목적지 컴퓨터(IP 주소)까지 패킷을 배달.
4. 네트워크 인터페이스: 실제 물리적인 선.

### 접속 과정 (브라우저가 URL을 쳤을 때)
1. 브라우저가 URL에서 호스트명(www.google.com)을 추출한다.
2. 브라우저가 DNS 서버에 호스트명의 IP 주소를 물어본다
3. IP 주소를 얻으면, 포트 번호(HTTP는 기본 80)를 확인한다.
4. 브라우저가 해당 IP:Port로 TCP 커넥션을 맺는다.
5. 브라우저가 HTTP 요청 메시지를 보낸다.
6. 서버가 HTTP 응답 메시지를 보낸다.
7. 커넥션을 끊는다 (HTTP/1.1의 Keep-Alive 설정에 따라 유지될 수도 있음).

---

## 웹의 구성 요소
인터넷은 단순한 1:1 연결이 아니라 중간에 수많은 중개자가 존재한다.
1. 프락시(Proxy): 클라이언트와 서버 사이에서 HTTP 메시지를 정리하거나, 보안 검사를 수행하는 중개 서버.
2. 캐시(Cache): 자주 요청받는 리소스의 사본을 저장해두는 특별한 종류의 프락시. 서버 부하를 줄이고 응답 속도를 높인다.
3. 게이트웨이(Gateway): 다른 프로토콜을 HTTP로 변환해준다.
   - 예: HTTP 트래픽을 받아서 SQL 쿼리로 변환해 DB에 접속하는 서버.
4. 터널(Tunnel): HTTP 메시지를 엿보지 않고 그대로 전달만 해주는 파이프.
   - 예: SSL/TLS(HTTPS) 통신 시 암호화된 데이터를 통과시킬 때 사용.
5. 에이전트(Agent): HTTP 요청을 발생시키는 주체.
    - 대표적인 예: 웹 브라우저, 웹 크롤러(스파이더).

---

## 오늘의 회고
1. 단순함의 미학: HTTP 메시지는 바이너리(0과 1)가 아니라 텍스트로 되어 있다. 이는 디버깅을 쉽게 하고 프로토콜의 확장을 용이하게 했다는 점이 인상 깊다. (Telnet으로 직접 요청을 날려볼 수 있는 이유)
2. 상태 코드의 분류: 단순히 에러가 났다가 아니라, 4xx는 내(클라이언트) 잘못, 5xx는 서버 잘못이라는 책임 소재를 명확히 숫자로 구분한 설계가 효율적이다.
3. 계층의 분리: HTTP는 '어떻게 보낼지(Routing)'를 고민하지 않는다. 그건 TCP/IP가 한다. HTTP는 오직 '무엇을 보낼지'에만 집중한다. 이 추상화가 웹의 폭발적 성장을 가능하게 했다.

---
# URL과 리소스

## URL: 인터넷의 탐색 도구
URL은 브라우저가 리소스를 찾고, 사용하고, 가져오기 위해 필요한 모든 정보를 담고 있는 표준화된 이름이다.
- 역할: 리소스가 어디에 있고, 어떻게 접근해야하는지 알려준다.
- 구성: `스킴(Scheme)` + `호스트(Host)` + `경로(Path)`

---

## URL 문법
URL은 생각보다 복잡한 구조를 가질 수 있다. 일반적인 포맷은 다음과 같다.
`py <스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>`

### 각 구성요소의 역할
- 스킴(Scheme): 사용할 프로토콜을 정의.(대소문자 구별x, 보통 소문자 사용)
   - 예: `http, htpps, mailto, ftp` 등
   - 구분자: 뒤에 `://`가 붙는다.
- 사용자 이름 & 비밀번호: 데이터 접근시 인증이 필요한 경우 사용.
  - 예: `ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu`
  - 당연하게도 비밀번호를 URL에 평문으로 넣는것은 보안에 취약하기 때문에 거의 사용x
- 호스트 & 포트: 리소스를 가진 서버의 위치.
  - 호스트: 도메인명`www.google.com`또는 IP 주소.
  - 포트: 서버가 열고 있는 문. 80, 443 등
- 경로(Path): 서버내 리소스의 계층적 위치 `/`문자로 구분한다.
- 파라미터(Parameters): 애플리케이션에 필요한 추가 정보 전달. `;`문자로 구분한다.
  - 예: `/hammers;sale=false/index.html;graphics=true`
  - 참고: 경로의 각 세그먼트마다 파라미터가 붙을 수 있다.
- 질의 문자열(쿼리문): 데이터베이스나 게이트웨이에 파라미터 전달.
  - 예: `?item=12731&color=blue`
  - 구분자 `?`로 시작하며, `&`로 키-값 쌍을 나눈다.
- 프래그먼트(Fragment): 리소스 내부의 특정 조각(섹션)을 가리킨다.
  - 예: `#section-2`
  - 핵심: 프래그먼트는 서버로 전송되지 않는다. 브라우저(클라이언트)가 전체 문서를 받은 뒤 해당 위치로 이동하는 용도로만 사용.

---

## URL 단축과 상대 URL
항상 전체 URL(절대)을 다 쓰는 것은 비효율적이다. HTML 내에서는 상대 URL을 많이 사용한다.

### 기저(Base) URL
상대 URL을 해석하려면 기준이 되는 기저 URL이 필요하다.
1. 리소스 자체의 URL: 현재 보고 있는 페이지의 URL이 기저.
2. 명시적 설정: HTML의 `<base href="...">` 태그로 기저 URL을 고정할 수 있다.

### 상대 경로 해석법
유닉스/리눅스의 파일 시스템 경로와 유사.
- `./`:현재 디렉터리
- `../`: 상위 디렉터리
- `/`로 시작: 도메인 루트(Root)에서 시작
- 예) 기저가 `http://www.a.com/b/c/d.html` 일 때,
  - `e.html` -> `http://www.a.com/b/c/e.html`
  - `/f.html` -> `http://www.a.com/f.html`
---

## URL 인코딩
컴퓨터는 이진 데이터를 다루지만, URL은 안전한 정송을 위해 ASCII 문자 집합만을 사용해야함. 따라서 안전하지 않는 문자는 인코딩해서 사용해야 한다.

### 안전하지 않은 문자
- 출력 불가능한 문자: 제어 문자 등.
- 예약된 문자: URL에서 특별한 의미로 이미 사용중인 문자들 `(/, :, ?, @, & 등)`. 이들을 문자 그대로 데이터로 쓰고 싶다면 인코딩해야 한다.
- 비 ASCII 문자: 한글, 일본어 등 영어 이외의 문자.

### 이스케이프 문자열
안전하지 않은 문자를 `%` + `16진수 두 자리(Hex)`로 바꾼다.
- **스페이스(공백):** ASCII 32 -> %20
- **~ (물결표):** ASCII 126 -> %7E
- **한글:** UTF-8 바이트 값을 각각 %로 변환.

---

## 여러가지 스킴
- http: 일반적인 웹 통신.
- https: SSL/TLS로 암호화된 안전한 http.
- mailto: 이메일 보내기. (예: mailto:jo@jo.com)
- ftp: 파일 전송 프로토콜.
- rtsp: 실시간 스트리밍 프로토콜.
- file: 로컬 컴퓨터의 파일에 접근.

---

## 오늘의 회고
1. 프래그먼트(#)의 비밀: # 뒤의 내용은 서버 요청 로그에 남지 않는다는 점이 중요하다. 요즘 SPA(Single Page Application)에서 라우팅을 할 때 HashRouter를 쓰면 서버 설정 없이도 페이지 이동처럼 보이는 이유가 바로 이것이다.
2. 인코딩의 중요성: 개발하다 보면 검색어 파라미터에 특수문자(& 등)가 들어가서 쿼리 스트링이 깨지는 경우가 있다. 이때 반드시 encodeURIComponent 같은 함수로 인코딩을 해줘야 함을 이론적으로 재확인했다.
3. URL의 미래와 한계: URL은 리소스가 옮겨지면 링크가 깨지는(Link Rot) 문제가 있다. 이를 해결하기 위해 URN(이름)이 나왔지만, 인프라 비용과 표준화 문제로 여전히 URL이 지배적이라는 현실.