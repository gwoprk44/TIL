> HTTP 완벽 가이드 책을 읽고 정리한 내용입니다.

# HTTP 개관

## HTTP: 인터넷의 멀티미디어 배달부
HTTP는 단순한 텍스트 전송규약이 아닌, 전 세계 웹 서버와 클라이언트 간의 신뢰성있는 데이터 전송을 보장하는 애플리케이션 계층 프로토콜이다.

### 리소스와 MIME 타입
- 리소스: 웹에 존재하는 모든 컨텐츠(파일, 게이트웨이 프로그램, 검색 결과 등)을 총칭
- MIME 타입:
  - 원래 이메일 전송을 위해 설계되었으나 HTTP에서도 사용된다.
  - 서버는 데이터 전송시 `Content-Type` 헤더를 통해 데이터의 형식을 알려준다.

### URI (Uniform Resource Identifier)
리소스의 고유 식별자. URI는 URL과 URN으로 나뉜다.
- URL(Locator): 리소스의 위치를 지정. 가장 일반적인 형태.
  - 구조: `<스킴>://<서버주소>:<포트>/<경로>`
  - 예: `http://www.naver.com:80/index.html`
- URN(Name): 리소스의 이름을 지정. 위치가 변해도 이름은 유지.
  - 예: `urn:isbn:978-0-123-45678-9`(아직 널리 쓰이지는 않는다.)

---

## HTTP 트랜잭션
HTTP 트랜잭션은 요청(Request)와 응답(Response) 결과로 구성된다.

### 메서드: 서버에게 무엇을 시키는가
모든 서버가 모든 메서드를 지원하는것은 아님.
- GET: 리소스를 서버에서 클라이언트로 가져온다. (가장 많이 사용)
- POST: 클라이언트가 서버로 데이터를 보낸다. (입력 폼 전송 등)
- PUT: 서버에 문서를 저장하거나 덮어쓴다.
- DELETE: 서버에서 리소스를 삭제한다.
- HEAD: GET과 같지만, 본문(Body) 없이 헤더만 가져온다. (리소스 존재 여부 확인, 변경 여부 검사 시 유용)

### 상태코드: 결과가 어떠한가
세 자리 숫자로 구성되며, 함께 오는 사유 구문은 사람이 이해하기 위한 것.
- 100-199: 정보 (Information)
- 200-299: 성공 (Success) -> 200 OK
- 300-399: 리다이렉션 (Redirection) -> 302 Found (다른 위치로 가라)
- 400-499: 클라이언트 에러 (Client Error) -> 404 Not Found (네가 요청한 게 없다)
- 500-599: 서버 에러 (Server Error) -> 500 Internal Server Error (서버 내부 문제)

---

## 메시지 구조
HTTP 메시지는 인간이 읽을 수 있는 텍스트로 되어있다.

### 요청 메시지 (Request)
1. 시작줄: `<메서드> <URL> <버전>`
   - 예: `GET /index.html HTTP/1.1`
2. 헤더: 키: 값 형태의 메타 정보.(빈 줄로 헤더의 끝을 알린다.)
3. 본문: POST 요청시 보낼 데이터

### 응답 메시지 (Response)
1. 시작줄: `<버전> <상태코드> <사유구문>`
   - 예: `HTTP/1.1 200 OK`
2. 헤더: 컨텐츠 타입, 길이, 서버 정보 등.
3. 본문: 실제 데이터

---

## TCP 커넥션
HTTP는 네트워크 통신의 핵심인 데이터 전송을 TCP/IP에 맡긴다.

### 계층 구조
1. HTTP (애플리케이션 계층): 무엇을 보낼지 결정.
2. TCP (전송 계층): 데이터를 패킷 단위로 쪼개고, 순서대로, 에러 없이 도착하도록 보장.
3. IP (네트워크 계층): 목적지 컴퓨터(IP 주소)까지 패킷을 배달.
4. 네트워크 인터페이스: 실제 물리적인 선.

### 접속 과정 (브라우저가 URL을 쳤을 때)
1. 브라우저가 URL에서 호스트명(www.google.com)을 추출한다.
2. 브라우저가 DNS 서버에 호스트명의 IP 주소를 물어본다
3. IP 주소를 얻으면, 포트 번호(HTTP는 기본 80)를 확인한다.
4. 브라우저가 해당 IP:Port로 TCP 커넥션을 맺는다.
5. 브라우저가 HTTP 요청 메시지를 보낸다.
6. 서버가 HTTP 응답 메시지를 보낸다.
7. 커넥션을 끊는다 (HTTP/1.1의 Keep-Alive 설정에 따라 유지될 수도 있음).

---

## 웹의 구성 요소
인터넷은 단순한 1:1 연결이 아니라 중간에 수많은 중개자가 존재한다.
1. 프락시(Proxy): 클라이언트와 서버 사이에서 HTTP 메시지를 정리하거나, 보안 검사를 수행하는 중개 서버.
2. 캐시(Cache): 자주 요청받는 리소스의 사본을 저장해두는 특별한 종류의 프락시. 서버 부하를 줄이고 응답 속도를 높인다.
3. 게이트웨이(Gateway): 다른 프로토콜을 HTTP로 변환해준다.
   - 예: HTTP 트래픽을 받아서 SQL 쿼리로 변환해 DB에 접속하는 서버.
4. 터널(Tunnel): HTTP 메시지를 엿보지 않고 그대로 전달만 해주는 파이프.
   - 예: SSL/TLS(HTTPS) 통신 시 암호화된 데이터를 통과시킬 때 사용.
5. 에이전트(Agent): HTTP 요청을 발생시키는 주체.
    - 대표적인 예: 웹 브라우저, 웹 크롤러(스파이더).

---

## 오늘의 회고
1. 단순함의 미학: HTTP 메시지는 바이너리(0과 1)가 아니라 텍스트로 되어 있다. 이는 디버깅을 쉽게 하고 프로토콜의 확장을 용이하게 했다는 점이 인상 깊다. (Telnet으로 직접 요청을 날려볼 수 있는 이유)
2. 상태 코드의 분류: 단순히 에러가 났다가 아니라, 4xx는 내(클라이언트) 잘못, 5xx는 서버 잘못이라는 책임 소재를 명확히 숫자로 구분한 설계가 효율적이다.
3. 계층의 분리: HTTP는 '어떻게 보낼지(Routing)'를 고민하지 않는다. 그건 TCP/IP가 한다. HTTP는 오직 '무엇을 보낼지'에만 집중한다. 이 추상화가 웹의 폭발적 성장을 가능하게 했다.