> HTTP 완벽 가이드 책을 읽고 정리한 내용입니다.

# HTTP 개관

## HTTP: 인터넷의 멀티미디어 배달부
HTTP는 단순한 텍스트 전송규약이 아닌, 전 세계 웹 서버와 클라이언트 간의 신뢰성있는 데이터 전송을 보장하는 애플리케이션 계층 프로토콜이다.

### 리소스와 MIME 타입
- 리소스: 웹에 존재하는 모든 컨텐츠(파일, 게이트웨이 프로그램, 검색 결과 등)을 총칭
- MIME 타입:
  - 원래 이메일 전송을 위해 설계되었으나 HTTP에서도 사용된다.
  - 서버는 데이터 전송시 `Content-Type` 헤더를 통해 데이터의 형식을 알려준다.

### URI (Uniform Resource Identifier)
리소스의 고유 식별자. URI는 URL과 URN으로 나뉜다.
- URL(Locator): 리소스의 위치를 지정. 가장 일반적인 형태.
  - 구조: `<스킴>://<서버주소>:<포트>/<경로>`
  - 예: `http://www.naver.com:80/index.html`
- URN(Name): 리소스의 이름을 지정. 위치가 변해도 이름은 유지.
  - 예: `urn:isbn:978-0-123-45678-9`(아직 널리 쓰이지는 않는다.)

---

## HTTP 트랜잭션
HTTP 트랜잭션은 요청(Request)와 응답(Response) 결과로 구성된다.

### 메서드: 서버에게 무엇을 시키는가
모든 서버가 모든 메서드를 지원하는것은 아님.
- GET: 리소스를 서버에서 클라이언트로 가져온다. (가장 많이 사용)
- POST: 클라이언트가 서버로 데이터를 보낸다. (입력 폼 전송 등)
- PUT: 서버에 문서를 저장하거나 덮어쓴다.
- DELETE: 서버에서 리소스를 삭제한다.
- HEAD: GET과 같지만, 본문(Body) 없이 헤더만 가져온다. (리소스 존재 여부 확인, 변경 여부 검사 시 유용)

### 상태코드: 결과가 어떠한가
세 자리 숫자로 구성되며, 함께 오는 사유 구문은 사람이 이해하기 위한 것.
- 100-199: 정보 (Information)
- 200-299: 성공 (Success) -> 200 OK
- 300-399: 리다이렉션 (Redirection) -> 302 Found (다른 위치로 가라)
- 400-499: 클라이언트 에러 (Client Error) -> 404 Not Found (네가 요청한 게 없다)
- 500-599: 서버 에러 (Server Error) -> 500 Internal Server Error (서버 내부 문제)

---

## 메시지 구조
HTTP 메시지는 인간이 읽을 수 있는 텍스트로 되어있다.

### 요청 메시지 (Request)
1. 시작줄: `<메서드> <URL> <버전>`
   - 예: `GET /index.html HTTP/1.1`
2. 헤더: 키: 값 형태의 메타 정보.(빈 줄로 헤더의 끝을 알린다.)
3. 본문: POST 요청시 보낼 데이터

### 응답 메시지 (Response)
1. 시작줄: `<버전> <상태코드> <사유구문>`
   - 예: `HTTP/1.1 200 OK`
2. 헤더: 컨텐츠 타입, 길이, 서버 정보 등.
3. 본문: 실제 데이터

---

## TCP 커넥션
HTTP는 네트워크 통신의 핵심인 데이터 전송을 TCP/IP에 맡긴다.

### 계층 구조
1. HTTP (애플리케이션 계층): 무엇을 보낼지 결정.
2. TCP (전송 계층): 데이터를 패킷 단위로 쪼개고, 순서대로, 에러 없이 도착하도록 보장.
3. IP (네트워크 계층): 목적지 컴퓨터(IP 주소)까지 패킷을 배달.
4. 네트워크 인터페이스: 실제 물리적인 선.

### 접속 과정 (브라우저가 URL을 쳤을 때)
1. 브라우저가 URL에서 호스트명(www.google.com)을 추출한다.
2. 브라우저가 DNS 서버에 호스트명의 IP 주소를 물어본다
3. IP 주소를 얻으면, 포트 번호(HTTP는 기본 80)를 확인한다.
4. 브라우저가 해당 IP:Port로 TCP 커넥션을 맺는다.
5. 브라우저가 HTTP 요청 메시지를 보낸다.
6. 서버가 HTTP 응답 메시지를 보낸다.
7. 커넥션을 끊는다 (HTTP/1.1의 Keep-Alive 설정에 따라 유지될 수도 있음).

---

## 웹의 구성 요소
인터넷은 단순한 1:1 연결이 아니라 중간에 수많은 중개자가 존재한다.
1. 프락시(Proxy): 클라이언트와 서버 사이에서 HTTP 메시지를 정리하거나, 보안 검사를 수행하는 중개 서버.
2. 캐시(Cache): 자주 요청받는 리소스의 사본을 저장해두는 특별한 종류의 프락시. 서버 부하를 줄이고 응답 속도를 높인다.
3. 게이트웨이(Gateway): 다른 프로토콜을 HTTP로 변환해준다.
   - 예: HTTP 트래픽을 받아서 SQL 쿼리로 변환해 DB에 접속하는 서버.
4. 터널(Tunnel): HTTP 메시지를 엿보지 않고 그대로 전달만 해주는 파이프.
   - 예: SSL/TLS(HTTPS) 통신 시 암호화된 데이터를 통과시킬 때 사용.
5. 에이전트(Agent): HTTP 요청을 발생시키는 주체.
    - 대표적인 예: 웹 브라우저, 웹 크롤러(스파이더).

---

## 오늘의 회고
1. 단순함의 미학: HTTP 메시지는 바이너리(0과 1)가 아니라 텍스트로 되어 있다. 이는 디버깅을 쉽게 하고 프로토콜의 확장을 용이하게 했다는 점이 인상 깊다. (Telnet으로 직접 요청을 날려볼 수 있는 이유)
2. 상태 코드의 분류: 단순히 에러가 났다가 아니라, 4xx는 내(클라이언트) 잘못, 5xx는 서버 잘못이라는 책임 소재를 명확히 숫자로 구분한 설계가 효율적이다.
3. 계층의 분리: HTTP는 '어떻게 보낼지(Routing)'를 고민하지 않는다. 그건 TCP/IP가 한다. HTTP는 오직 '무엇을 보낼지'에만 집중한다. 이 추상화가 웹의 폭발적 성장을 가능하게 했다.

---
# URL과 리소스

## URL: 인터넷의 탐색 도구
URL은 브라우저가 리소스를 찾고, 사용하고, 가져오기 위해 필요한 모든 정보를 담고 있는 표준화된 이름이다.
- 역할: 리소스가 어디에 있고, 어떻게 접근해야하는지 알려준다.
- 구성: `스킴(Scheme)` + `호스트(Host)` + `경로(Path)`

---

## URL 문법
URL은 생각보다 복잡한 구조를 가질 수 있다. 일반적인 포맷은 다음과 같다.
`py <스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>`

### 각 구성요소의 역할
- 스킴(Scheme): 사용할 프로토콜을 정의.(대소문자 구별x, 보통 소문자 사용)
   - 예: `http, htpps, mailto, ftp` 등
   - 구분자: 뒤에 `://`가 붙는다.
- 사용자 이름 & 비밀번호: 데이터 접근시 인증이 필요한 경우 사용.
  - 예: `ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu`
  - 당연하게도 비밀번호를 URL에 평문으로 넣는것은 보안에 취약하기 때문에 거의 사용x
- 호스트 & 포트: 리소스를 가진 서버의 위치.
  - 호스트: 도메인명`www.google.com`또는 IP 주소.
  - 포트: 서버가 열고 있는 문. 80, 443 등
- 경로(Path): 서버내 리소스의 계층적 위치 `/`문자로 구분한다.
- 파라미터(Parameters): 애플리케이션에 필요한 추가 정보 전달. `;`문자로 구분한다.
  - 예: `/hammers;sale=false/index.html;graphics=true`
  - 참고: 경로의 각 세그먼트마다 파라미터가 붙을 수 있다.
- 질의 문자열(쿼리문): 데이터베이스나 게이트웨이에 파라미터 전달.
  - 예: `?item=12731&color=blue`
  - 구분자 `?`로 시작하며, `&`로 키-값 쌍을 나눈다.
- 프래그먼트(Fragment): 리소스 내부의 특정 조각(섹션)을 가리킨다.
  - 예: `#section-2`
  - 핵심: 프래그먼트는 서버로 전송되지 않는다. 브라우저(클라이언트)가 전체 문서를 받은 뒤 해당 위치로 이동하는 용도로만 사용.

---

## URL 단축과 상대 URL
항상 전체 URL(절대)을 다 쓰는 것은 비효율적이다. HTML 내에서는 상대 URL을 많이 사용한다.

### 기저(Base) URL
상대 URL을 해석하려면 기준이 되는 기저 URL이 필요하다.
1. 리소스 자체의 URL: 현재 보고 있는 페이지의 URL이 기저.
2. 명시적 설정: HTML의 `<base href="...">` 태그로 기저 URL을 고정할 수 있다.

### 상대 경로 해석법
유닉스/리눅스의 파일 시스템 경로와 유사.
- `./`:현재 디렉터리
- `../`: 상위 디렉터리
- `/`로 시작: 도메인 루트(Root)에서 시작
- 예) 기저가 `http://www.a.com/b/c/d.html` 일 때,
  - `e.html` -> `http://www.a.com/b/c/e.html`
  - `/f.html` -> `http://www.a.com/f.html`
---

## URL 인코딩
컴퓨터는 이진 데이터를 다루지만, URL은 안전한 정송을 위해 ASCII 문자 집합만을 사용해야함. 따라서 안전하지 않는 문자는 인코딩해서 사용해야 한다.

### 안전하지 않은 문자
- 출력 불가능한 문자: 제어 문자 등.
- 예약된 문자: URL에서 특별한 의미로 이미 사용중인 문자들 `(/, :, ?, @, & 등)`. 이들을 문자 그대로 데이터로 쓰고 싶다면 인코딩해야 한다.
- 비 ASCII 문자: 한글, 일본어 등 영어 이외의 문자.

### 이스케이프 문자열
안전하지 않은 문자를 `%` + `16진수 두 자리(Hex)`로 바꾼다.
- **스페이스(공백):** ASCII 32 -> %20
- **~ (물결표):** ASCII 126 -> %7E
- **한글:** UTF-8 바이트 값을 각각 %로 변환.

---

## 여러가지 스킴
- http: 일반적인 웹 통신.
- https: SSL/TLS로 암호화된 안전한 http.
- mailto: 이메일 보내기. (예: `mailto:jo@jo.com`)
- ftp: 파일 전송 프로토콜.
- rtsp: 실시간 스트리밍 프로토콜.
- file: 로컬 컴퓨터의 파일에 접근.

---

## 오늘의 회고
1. 프래그먼트(#)의 비밀: # 뒤의 내용은 서버 요청 로그에 남지 않는다는 점이 중요하다. 요즘 SPA(Single Page Application)에서 라우팅을 할 때 HashRouter를 쓰면 서버 설정 없이도 페이지 이동처럼 보이는 이유가 바로 이것이다.
2. 인코딩의 중요성: 개발하다 보면 검색어 파라미터에 특수문자(& 등)가 들어가서 쿼리 스트링이 깨지는 경우가 있다. 이때 반드시 encodeURIComponent 같은 함수로 인코딩을 해줘야 함을 이론적으로 재확인했다.
3. URL의 미래와 한계: URL은 리소스가 옮겨지면 링크가 깨지는(Link Rot) 문제가 있다. 이를 해결하기 위해 URN(이름)이 나왔지만, 인프라 비용과 표준화 문제로 여전히 URL이 지배적이라는 현실.

---

# HTTP 메시지

## 메시지의 흐름
HTTP 메시지는 강물 처럼 흐름이 존재한다.

- 인바운드 vs 아웃바운드
  - 트랜잭션 방향을 기준으로 한다.
  - 메시지가 원 서버로 향하면 인바운드.
  - 메시지가 사용자 에이전트로 돌아오면 아웃바운드.
- 다운 스트림
  - 모든 메시지(요청이든 응답이든)는 다운스트림으로 흐른다.
  - 발송자 -> 수신자 방향이 물이 흐르는 방향이다.(거꾸로 거슬러 올라가는 메시지는 존재하지않는다.)

---

## 메시지의 해부
HTTP 메시지는 세 부분으로 나뉜다. 엄격한 규칙은 **CRLF(캐리지 리턴 + 개행)**으로 구분된다는 점이다.

`py <시작줄> (CRLF) <헤더> (CRLF) <빈 줄> (CRLF) --> 헤더의 끝을 알리는 매우 중요한 경계선 <본문>`

### 구성 요소
- 시작줄: 이것이 어떤 메시지인지 정의.
  - 요청: `<메서드> <URL> <버전> (예: GET /home HTTP/1.1)`
  - 응답: `<버전> <상태코드> <사유구문> (예: HTTP/1.1 200 OK)`
- 헤더: 속성 정보. `(예: Content-Type: text/html)`
- 본문: 페이로드. 이미지, 비디오, HTML 문서, 텍스트 등. 본문이 없을수도 있다.

---

## 메서드 심화
단순히 동작을 지시하는 것을 넘어, 안전성과 멱등성이란 속성을 이해하는것이 핵심.

### 주요 메서드
- GET: 리소스 요청.
- HEAD: 리소스의 헤더만 요청. (본문은 안 옴).
  - 용도: 리소스가 살아있는지, 변경되었는지(Last-Modified), 타입이 무엇인지 미리 확인할 때 효율적.
- POST: 서버에 입력 데이터 전송. (보통 처리 주체는 서버의 게이트웨이 프로그램).
- PUT: 리소스를 생성하거나, 있으면 덮어씌움(Update).
- DELETE: 리소스 삭제.
- TRACE: 루프백(Loopback) 테스트.
  - 클라이언트가 보낸 요청이 프락시들을 거치며 어떻게 변조되는지 서버가 그대로 반송해서 보여줌. (디버깅용)
- OPTIONS: 서버가 특정 리소스에 대해 어떤 메서드를 지원하는지 물어봄.

### 안전성과 멱등성
1. 안전한 메서드: `GET, HEAD`
   - 서버의 상태를 바꾸지 않는다(Read Only).
   - 크롤러가 막 호출해도 서버에 영향을 주지 않아야한다.
2. 멱등성:
   - 연산을 한 번 하든, 백 번 하든 결과가 똑같은 성질.
   - 멱등함: `GET, PUT, DELETE`
     - `PUT`: 같은 내용으로 100번 덮어써도, 결과물은 그 내용 하나이다.
     - `DELETE`: 한 번 삭제하나, 삭제된걸 또 삭제 요청하나 삭제된 상태는 같다.
  - 멱등하지 않음: `POST`
    - 게시글 작성 버튼을 100번 누르면 게시글이 100개 생긴다. (따라서 결제 페이지 등에서 중복 전송 방지가 중요.)
---

## 상태 코드 상세
상태 코드는 클라이언트 소프트웨어(브라우저)가 처리하는 기준이고, 사유 구문(Reason Phrase)은 오직 사람을 위한 설명이다.

- 100 Continue: (1xx) 클라이언트가 본문을 보내기 전, 헤더만 먼저 보내서 "이거 보내도 돼?" 물어볼 때 사용.
- 200 OK: (2xx) 성공. 가장 일반적.
- 301 Moved Permanently: (3xx) 리소스가 영원히 이사 감. 브라우저는 북마크를 갱신해야 함.
- 302 Found: (3xx) 리소스가 잠깐 이사 감. (대부분의 리다이렉트).
- 304 Not Modified: (3xx) 조건부 요청 시, "네가 가진 캐시랑 똑같으니 그거 써라"는 뜻. (본문 없음, 대역폭 절약).
- 401 Unauthorized: (4xx) 인증 필요 (로그인 해라).
- 403 Forbidden: (4xx) 서버가 요청을 거부함 (권한 없음, 파일 숨김 등).
- 405 Method Not Allowed: (4xx) 해당 URL에 그 메서드(예: DELETE)는 못 쓴다.
- 502 Bad Gateway: (5xx) 프락시나 게이트웨이가 업스트림 서버로부터 이상한 응답을 받음.

---

## 헤더 분류
헤더는 어디에 쓰이느냐에 따라 5가지로 나뉜다.
1. 일반 헤더 (General): 요청/응답 양쪽에 모두 쓰임. (예: Date, Connection)
2. 요청 헤더 (Request): 클라이언트 정보나 선호도. (예: User-Agent, Accept-Language)
3. 응답 헤더 (Response): 서버 정보. (예: Server, Retry-After)
4. 엔터티 헤더 (Entity): 본문(Payload)에 대한 설명. 본문이 없어도 있을 수 있음. (예: Content-Type, Content-Length)
5. 확장 헤더 (Extension): 표준에 없지만 개발자가 임의로 만든 헤더. (과거엔 X-를 붙였으나 요즘은 안 붙이는 추세)

---

## 오늘의 회고
1. 빈 줄(CRLF)의 역할: 헤더와 본문을 구분하는 것이 고작 '빈 줄' 하나라는 점이 HTTP의 단순함을 보여준다. 하지만 코딩할 때 이 빈 줄을 빠뜨리면 서버는 헤더가 계속되는 줄 알고 무한 대기할 수 있다.
2. 멱등성의 실무적 중요성: 네트워크 오류로 패킷이 유실됐을 때, 클라이언트가 자동으로 재시도(Retry) 해도 되는지 판단하는 기준이 바로 멱등성이다. POST 요청이 실패했을 때 함부로 재전송하면 중복 결제가 될 수 있으니 조심해야 한다는 원리를 깨달았다.
3. 304 Not Modified의 경제학: 이 코드는 본문 데이터를 보내지 않음으로써 인터넷 트래픽을 어마어마하게 절약해주는 일등 공신이다. 캐시 최적화의 핵심이다.

---                 

# 커넥션 관리

## TCP 커넥션의 이해
HTTP 메시지는 반드시 TCP 커넥션을 맺은 이후에 데이터를 보낼 수 있다. 따라서 HTTP 성능은 TCP 성능에 크게 좌우된다.

### TCP 커넥션의 지연 요소
웹 브라우저가 느리게 느껴지는 경우 대부분 지연 때문인 경우가 많다.
- TCP 핸드셰이크 지연:
  - 새로운 연결을 맺을 때 마다 `SYN` -> `SYN+ACK` -> `ACK`의 3-way handshake가 필요하다. 작은 데이터를 보낼 때도 이 과정이 필수라 오버헤드가 크다.
- TCP 느린 시작:
  - TCP는 처음에는 패킷을 천천히 보내다가 성공하면 속도를 높인다. (혼잡 제어)
  - 새로 맺은 커넥션은 튜닝되지 않아 속도가 느리다. 이미 튜닝된 커넥션을 사용하는게 중요하다.
- 네이글 알고리즘:
  - 작은 패킷 여러개을 모아서 한번에 보낸다. 효율적이지만, HTTP 처럼 요청-응답이 즉시 필요한 경우 지연을 유발한다.(HTTP는 `TCP_NODELAY`로 끈다.)
- TIME_WAIT 누적
  - 커넥션을 끊은 쪽에서 일정 시간 동안 포트를 점유하고 있는다. 커넥션을 너무 자주 맺고 끊으면 가용 포트가 고갈될 수 있다.

---

## HTTP 커넥션 관리 모델
초기 HTTP부터 현재까지 커넥션을 효율적으로 사용하기 위해 모델이 진화.

### 병렬 커넥션
- 방식: 브라우저가 여러 개의 TCP 커넥션(보통 6개)을 동시에 맺어 여러 이미지나 파일을 한꺼번에 내려받는다.
- 장점: 사용자가 보기에 페이지가 빨리 뜨는 것처럼 느껴진다.
- 단점: 서버 메모리를 많이 잡아먹고, 각 커넥션마다 핸드셰이크/느린 시작 비용이 발생한다.

### 지속 커넥션
- 방식: 처리가 완료된 커넥션을 끊지 않고, 계속 연결해 둔 상태로 다음 요청을 보낸다.
- 장점:
  - 핸드셰이크 시간 절약.
  - TCP "느린 시작" 단계를 건너뛰고 튜닝된 속도로 전송 가능.
- 종류:
  - HTTP/1.0+ Keep-Alive: 실험적인 모델. 헤더에 Connection: Keep-Alive를 명시해야 함.
  - HTTP/1.1 Persistent: 기본적으로 지속 커넥션. 끊으려면 Connection: close를 명시해야 함.

---

## Keep-Alive와 멍청한(Dumb)프락시 문제
HTTP/1.0의 `Keep-Alive` 설계에는 치명적인 결함이 있었다.

### 멍청한 프락시
1. 클라이언트가 `Connection: Keep-Alive` 헤더를 보내며 연결 유지를 요청함.
2. 중간에 있는 오래된 프락시는 이 헤더의 의미를 모른다.
3. 프락시는 이 헤더를 그대로 서버에 전달(Relay) 해버린다. (Hop-by-Hop 헤더는 전달하면 안 되는데 규칙을 모름).
4. 서버는 프락시가 연결 유지를 원하는 줄 알고 동의함.
5. 결과: 프락시는 통신이 끝난 줄 알고 기다리고(Hung), 서버는 프락시의 다음 요청을 기다리고, 클라이언트는 응답을 기다리는 무한 대기(Hang) 상태에 빠진다.

### 해결책: Proxy-Connection 헤더
이 문제를 피하기 위해 브라우저는 비표준인 `Proxy-Connection` 헤더를 사용하기도 한다. 멍청한 프락시는 이걸 그대로 넘기지만, 영리한 프락시는 이걸 보고 `Connection: Keep-Alive`로 바꿔서 서버에 보낸다.

---

## 파이프라인 커넥션
HTTP/1.1에서 지속 커넥션을 더 효율적으로 쓰기 위해 제안된 기술.

- 방식: 요청을 보내고 응답을 기다리지 않고, 연속해서 요청을 쏜다. (요청1 -> 요청2 -> 요청3 ... 응답1 -> 응답2 -> 응답3)
- 제약:
  - 응답은 반드시 요청 순서대로 와야 한다.
  - 중간에 하나가 막히면 뒤에 것도 다 막힌다 (HOL Blocking 문제).
  - 실무: 구현이 복잡하고 버그가 많아 실제로는 잘 안 쓰임 (HTTP/2에서 멀티플렉싱으로 해결됨).

---

## 커넥션 끊기
영원한 커넥션은 없다. 언제 어떻게 끊느냐가 중요하다.

- 우아한 종료 (Graceful Close):
  - TCP는 양방향 통신이다. 입력 채널과 출력 채널이 따로 있다.
  - 갑자기 close()를 부르면 전송 중이던 데이터가 유실될 수 있다.
  - 자신의 출력 채널만 먼저 닫고(shutdown), 상대방의 데이터가 다 올 때까지 기다리는 것이 안전하다.
- Content-Length의 중요성: 지속 커넥션에서는 메시지의 끝을 알아야 한다. Content-Length 값이 틀리면 커넥션은 다음 데이터를 하염없이 기다리거나, 다음 요청을 데이터로 착각하게 된다.

---

## 오늘의 회고
1. "이미 맺어진 커넥션이 가장 빠르다": 웹 최적화의 제1원칙은 불필요한 바이트를 줄이는 것이지만, 제2원칙은 기존 커넥션을 재활용하는 것이다. TCP 3-way handshake 비용이 생각보다 비싸다는 것을 깨달았다.
2. Hop-by-Hop 헤더의 위험성: Connection 헤더는 딱 나와 내 옆의 녀석(프락시) 사이에서만 유효하고 삭제되어야 한다. 이를 어기면 전체 통신이 마비될 수 있다는 '멍청한 프락시' 시나리오가 매우 흥미롭다.
3. HTTP/1.1의 위대함: HTTP/1.1이 단순히 기능 추가가 아니라, 1.0의 커넥션 관리 문제(성능 저하)를 해결하기 위해 '지속 커넥션'을 기본(Default)으로 채택했다는 점이 프로토콜 설계의 진화를 보여준다.

---