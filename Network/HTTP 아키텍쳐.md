# SQ3R

## 프록시

### Proxy vs Gateway

`Proxy` 는 **같은 프로토콜**을 사용하는 둘 이상의 애플리케이션을 연결하고,

Gateway 는 **서로 다른 프로토콜**을 사용하는 둘 이상을 연결한다.

Gateway는 서로 다른 프로토콜로 이야기를 하더라도 서로간의 트랜잭션을 완료.

### Proxy를 사용하는 이유?

- 어린이 필터
- 문서 접근 제어자: 웹 리소스에 대한 접근 제어를 각각 가지는게 아니라, **중앙 집권**하기 위해 사용
- 보안 방화벽
- 웹 캐시: 인기 있는 로컬 사본을 관리하고, 해당 문서에 대한 요청이 오면 빠르게 제공
- 대리 프락시
- 콘텐츠 라우터
- 트랜스코더
- 익명화 프락시

## 캐시

캐시를 쓰는 이유?

- 불필요한 데이터 전송 방지
- 대역폭 병목 방지
- 갑작스런 요청에 대한 쇄도를 방지
- 거리로 인한 지연(latency)를 방지

캐시는 그래서 적중과 부적중, 재검사가가 존재.

- 적중: 그냥 캐시서버에 존재하는 내용을 사용한다.
- 부적중: 캐시서버에 없으면 본래 서버에서 꺼내와서 캐시서버에 저장한다.
- 재검사: `If-Modified-Since` 헤더를 활용해서 캐시된 시간 이후에 변경되었는지 확인하는 방법이다.
  - 만일 여기서 적중시, Client에게 **304(Not Modified)** 를
  - 부적중시, 서버는 콘텐츠와 함께 **200(Ok)** 를
  - 객체가 삭제시, **404(Not Found)** 를 전달한다.

## 캐시 사본을 유지하는 방법?

- 문서 만료시간 정의: `Expires` 헤더와 `Cache-Control` 이라는 특별한 헤더를 사용한다.
  - Cache-Control: max-age=22 이런식으로 캐시에 만료 날짜를 명시한다.
  - Expires 라는 절대 유효기간을 명시한다.
- 서버 재검사
  - 캐시된 문서가 만료되었음을 서버에게 물어보는 것
  - 검사 결과 콘텐츠 변경되었으면 **서버로부터 가져오면 되**는 거고
  - 콘텐츠 변경이 없다면 **새 만료일을 포함한 새로운 헤더만 가져오면 된다.**

그러면 재검사를 어떻게 하는가?

가장 흔히쓰이는 것은 `If-Modified-Since` : 주어진 날짜로부터 수정되었다면 서버는 요청을 처리한다.

만약 수정이 안되었으면 **304(Not Modified)** 를 응답한다.

다음으로는 `If-None-Match` : 일종의 버젼정보(`ETag`)를 바탕으로 최신 데이터인지 확인하는 방식이다.

## HTTP/2.0

한 개의 스트림에서 한쌍의 요청과 응답을 처리할 수 있다.
또한 한 개의 커넥션에서 여러개의 `스트림` 을 만들 수 있으므로 동시 처리가 가능하다 .
이들 `스트림` 에 대해서 흐름 제어와 우선순위 부여 기능도 제공한다.
